<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://jkfx.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jkfx.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-03-14T02:43:45+00:00</updated><id>https://jkfx.github.io/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">LaTeX 不太简短的介绍</title><link href="https://jkfx.github.io/blog/2025/LaTeX%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D/" rel="alternate" type="text/html" title="LaTeX 不太简短的介绍"/><published>2025-03-02T11:13:00+00:00</published><updated>2025-03-02T11:13:00+00:00</updated><id>https://jkfx.github.io/blog/2025/LaTeX%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="https://jkfx.github.io/blog/2025/LaTeX%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D/"><![CDATA[<h2 id="latex-的基本概念">LaTeX 的基本概念</h2> <h3 id="概述">概述</h3> <p>Tex 是高德纳为排版文字和数学公式而开发的软件。</p> <p>LaTeX 是一种使用 Tex 程序作为排版引擎的格式，可以粗略地将它理解成是对 Tex 的一层封装。</p> <p>LaTeX 最初的设计目的是<strong>分离内容与格式</strong>，以便作者能够<strong>专注于内容创作而非排版设计</strong>，并能以此得到高质量排版的作品。</p> <h3 id="latex-命令和代码结构">LaTeX 命令和代码结构</h3> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>ctexart<span class="p">}</span>
<span class="nt">\begin{documeng}</span>
“你好，世界！”来自 <span class="k">\LaTeX</span><span class="p">{}</span> 的问候。
<span class="nt">\end{document}</span>
</code></pre></div></div> <p>字母形式的 LaTeX 命令忽略其后的所有连续空格。如果要人为引入空格，需要在命令后面加一对花括号阻止其忽略空格：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\TeX</span> 会忽略空格。
<span class="k">\TeX</span><span class="p">{}</span> 不会忽略空格。
</code></pre></div></div> <p>LaTeX 还包括<strong>环境</strong>，用以令一些效果在局部生效，或是生成特殊的文档元素。LaTeX 环境的用法为一对命令 <code class="language-plaintext highlighter-rouge">\begin</code> 和 <code class="language-plaintext highlighter-rouge">\end</code> ，部分环境允许嵌套使用：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{&lt;enviroment name&gt;}</span>[&lt;optional arguments&gt;]<span class="p">{</span>&lt;mandatory arguments&gt;<span class="p">}</span>
...
<span class="nt">\end{&lt;enviroment name&gt;}</span>
</code></pre></div></div> <p>有些命令（如 <code class="language-plaintext highlighter-rouge">\bfseries</code> ）会对其后所有内容产生作用。若要限制其作用范围，则需要使用<strong>分组</strong>。LaTeX 使用一对花括号 <code class="language-plaintext highlighter-rouge">{</code> 和 <code class="language-plaintext highlighter-rouge">}</code> 作为分组，在分组中使用的命令被限制在分组内，不会影响到分组外的内容（<em>个别命令在分组内仍然会产生全局作用</em>）。上文提到的 LaTeX 环境隐含了一个分组，在环境中的命令被包裹在分组内。</p> <p>LaTeX 的源代码结构：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>...<span class="p">}</span> <span class="c">% ... 为某文档</span>
<span class="c">% 导言区</span>
<span class="nt">\begin{document}</span>
<span class="c">% 正文内容</span>
<span class="nt">\end{document}</span>
<span class="c">% 此后内容会被忽略</span>
</code></pre></div></div> <h3 id="latex-宏包和文档类">LaTeX 宏包和文档类</h3> <p><strong>文档类</strong>规定了 LaTeX 源代码所要生成的文档的性质——普通文章、书籍、演示文稿、个人简历等等。LaTeX 源代码的开头须用 <code class="language-plaintext highlighter-rouge">\documentclass</code> 指定文档类:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="na">[&lt;options&gt;]</span><span class="p">{</span>&lt;class-name&gt;<span class="p">}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">⟨class-name⟩</code> 为文档类的名称，如 LaTeX 提供的 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">report</code>、<code class="language-plaintext highlighter-rouge">book</code>，在其基础上派 生的一些文档类，如支持中文排版的 <code class="language-plaintext highlighter-rouge">ctexart</code>、<code class="language-plaintext highlighter-rouge">ctexrep</code>、<code class="language-plaintext highlighter-rouge">ctexbook</code>，或者有其它功能的一些文档类， 如 <code class="language-plaintext highlighter-rouge">moderncv</code>、`beamer 等。其中前三个习惯上称为“标准文档类”。</p> <p>可选参数 <code class="language-plaintext highlighter-rouge">⟨options⟩</code> 为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、 单双面等等。比如调用 article 文档类排版文章，指定纸张为 A4 大小，基本字号为 11pt，双面 排版:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="na">[11pt,twoside,a4paper]</span><span class="p">{</span>article<span class="p">}</span>
</code></pre></div></div> <p>LaTeX 的三个标准文档类可指定的选项包括:</p> <p><code class="language-plaintext highlighter-rouge">10pt, 11pt, 12pt</code> 指定文档的基本字号。默认为 10pt。<br/> <code class="language-plaintext highlighter-rouge">a4paper, letterpaper, ...</code> 指定纸张大小，默认为美式信纸letterpaper(8.5in×11in，大 约相当于 21.6 cm × 28.0 cm)。可指定选项还包括 a5paper，b5paper，executivepaper 和 legalpaper。有关纸张大小的更多细节。<br/> <code class="language-plaintext highlighter-rouge">twoside, oneside</code> 指定单面/双面排版。双面排版时，奇偶页的页眉页脚、页边距不同。article 和 report 默认为 oneside，book 默认为 twoside。<br/> <code class="language-plaintext highlighter-rouge">onecolumn, twocolumn</code> 指定单栏/双栏排版。默认为 onecolumn。<br/> <code class="language-plaintext highlighter-rouge">openright, openany</code> 指定新的一章 \chapter 是在奇数页(右侧)开始，还是直接紧跟着上一页开始。report 默认为 openany，book 默认为 openright。对 article 无效。<br/> <code class="language-plaintext highlighter-rouge">landscape</code> 指定横向排版。默认为纵向。<br/> <code class="language-plaintext highlighter-rouge">titlepage, notitlepage</code> 指定标题命令 \maketitle 是否生成单独的标题页。article 默认为 notitlepage，report 和 book 默认为 titlepage。<br/> <code class="language-plaintext highlighter-rouge">fleqn</code> 令行间公式左对齐。默认为居中对齐。<br/> <code class="language-plaintext highlighter-rouge">leqno</code> 将公式编号放在左边。默认为右边。<br/> <code class="language-plaintext highlighter-rouge">draft, final</code> 指定草稿/终稿模式。草稿模式下，断行不良(溢出)的地方会在行尾添加一个 黑色方块;插图、超链接等功能也会受这一组选项影响，具体见后文。默认为 final。</p> <p>在使用 LaTeX 时，时常需要依赖一些扩展来增强或补充 LaTeX 的功能，比如排版复杂的表格、插入图片、增加颜色甚至超链接等等。这些扩展称为<strong>宏包</strong>。调用宏包的方法非常类似调用文档类的方法:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\usepackage</span><span class="na">[⟨options⟩]</span><span class="p">{</span>⟨package-name⟩<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">\usepackage</code> 可以一次性调用多个宏包，在 <code class="language-plaintext highlighter-rouge">⟨package-name⟩</code> 中用逗号隔开。这种用法一般 不要指定选项 :</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% 一次性调用三个排版表格常用的宏包</span>
<span class="k">\usepackage</span><span class="p">{</span>tabularx, makecell, multirow<span class="p">}</span>
</code></pre></div></div> <p>宏包(包括前面所说的文档类)可能定义了许多命令和环境，或者修改了 LaTeX 已有的命令和环境。它们的用法说明记在相应宏包和文档类的帮助文档。在 Windows 命令提示符或者 Linux 终端下输入命令可查阅相应文档:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>texdoc ⟨pkg-name⟩
</code></pre></div></div> <h3 id="文件的组织方式">文件的组织方式</h3> <p>当编写长篇文档时，例如当编写书籍、毕业论文时，单个源文件会使修改、校对变得十分困难。将源文件分割成若干个文件，例如将每章内容单独写在一个文件中，会大大简化修改和校对的工作。</p> <p>LaTeX 提供了命令 <code class="language-plaintext highlighter-rouge">\include</code> 用来在源代码里插入文件:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\include</span><span class="p">{</span>⟨filename⟩<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">⟨filename⟩</code> 为文件名(不带 <code class="language-plaintext highlighter-rouge">.tex</code> 扩展名)，如果和要编译的主文件不在一个目录中，则要加上相对或绝对路径，例如:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\include</span><span class="p">{</span>chapters/file<span class="p">}</span> <span class="c">% 相对路径</span>
<span class="k">\include</span><span class="p">{</span>/home/Bob/file<span class="p">}</span> <span class="c">% *nix(包含 Linux、macOS)绝对路径 \include{D:/file} % Windows 绝对路径，用正斜线</span>
</code></pre></div></div> <p>值得注意的是 <code class="language-plaintext highlighter-rouge">\include</code> 在读入 <code class="language-plaintext highlighter-rouge">⟨filename⟩</code> 之前会另起一页。有的时候我们并不需要这样， 而是用 <code class="language-plaintext highlighter-rouge">\input</code> 命令，它纯粹是把文件里的内容插入:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\input</span><span class="p">{</span>⟨filename⟩<span class="p">}</span>
</code></pre></div></div> <p>当导言区内容较多时，常常将其单独放置在一个 <code class="language-plaintext highlighter-rouge">.tex</code> 文件中，再用 <code class="language-plaintext highlighter-rouge">\input</code> 命令插入。复杂的图、表、代码等也会用类似的手段处理。</p> <p>LaTeX 还提供了一个 <code class="language-plaintext highlighter-rouge">\includeonly</code> 命令来组织文件，用于<strong>导言区</strong>，指定只载入某些文件。 导言区使用了 <code class="language-plaintext highlighter-rouge">\includeonly</code> 后，正文中不在其列表范围的 <code class="language-plaintext highlighter-rouge">\include</code> 命令不会起效:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\includeonly</span><span class="p">{</span>⟨filename1⟩,⟨filename2⟩,...<span class="p">}</span>
</code></pre></div></div> <p>需要注意的是，使用 <code class="language-plaintext highlighter-rouge">\include</code> 和 <code class="language-plaintext highlighter-rouge">\input</code> 命令载入的文件名最好不要加空格和特殊字符， 也尽量避免使用中文名，否则很可能会出错。</p> <p>最后介绍一个实用的工具宏包 <code class="language-plaintext highlighter-rouge">syntonly</code>。加载这个宏包后，在导言区使用 <code class="language-plaintext highlighter-rouge">\syntaxonly</code> 命令，可令 LaTeX 编译后不生成 DVI 或者 PDF 文档，只排查错误，编译速度会快不少:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\usepackage</span><span class="p">{</span>syntonly<span class="p">}</span>
<span class="k">\syntaxonly</span>
</code></pre></div></div> <p>如果想生成文档，则用 <code class="language-plaintext highlighter-rouge">%</code> 注释掉 <code class="language-plaintext highlighter-rouge">\syntaxonly</code> 命令即可。</p> <h2 id="用-latex-排版文字">用 LaTeX 排版文字</h2> <p>随着 LaTeX 和底层 TEX 引擎的发展， 旧方式(CCT、CJK 等)日渐退出舞台，xelatex 和 lualatex 编译命令配合 ctex 宏包/文档类的方式成为当前的主流中文排版支持方式。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>ctexart<span class="p">}</span>
<span class="nt">\begin{document}</span>
在<span class="k">\LaTeX</span><span class="p">{}</span>中排版中文。 汉字和English单词混排，通常不需要在中英文之间添加额外的空格。 当然，为了代码的可读性，加上汉字和 English 之间的空格也无妨。 汉字换行时不会引入多余的空格。
<span class="nt">\end{document}</span>
</code></pre></div></div> <p>注意源代码须保存为 UTF-8 编码，并使用 xelatex 或 lualatex 命令编译。虽然 ctex 宏包和文档类保留了对 GBK 编码以及 latex 和 pdflatex 编译命令的兼容，但并不推荐这样做。</p> <h3 id="latex-中的字符">LaTeX 中的字符</h3> <p>LaTeX 源代码中，空格键和 Tab 键输入的空白字符视为“空格”。连续的若干个空白字符视为一个空格。一行开头的空格忽略不计。<br/> 行末的换行符视为一个空格;但连续两个换行符，也就是空行，会将文字分段。多个空行被视为一个空行。也可以在行末使用 <code class="language-plaintext highlighter-rouge">\par</code> 命令分段。</p> <p>LaTeX 用 <code class="language-plaintext highlighter-rouge">%</code> 字符作为注释。在这个字符之后直到行末，所有的字符都被忽略，行末的换行符也不引入空格。</p> <p>以下字符在 LaTeX 里有特殊用途，如 <code class="language-plaintext highlighter-rouge">%</code> 表示注释，<code class="language-plaintext highlighter-rouge">$</code>、<code class="language-plaintext highlighter-rouge">^</code>、<code class="language-plaintext highlighter-rouge">_</code> 等用于排版数学公式，<code class="language-plaintext highlighter-rouge">&amp;</code> 用于排版表格，等等。直接输入这些字符得不到对应的符号，还往往会出错。如果想要输入以上符号，需要使用以下带反斜线的形式输入，类似编程语言里的“转义”符号:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\#</span> <span class="k">\$</span> <span class="k">\%</span> <span class="k">\&amp;</span> <span class="k">\{</span> <span class="k">\}</span> <span class="k">\_</span>
<span class="k">\^</span><span class="p">{}</span> <span class="k">\~</span><span class="p">{}</span> <span class="k">\textbackslash</span>
</code></pre></div></div> <p>这些“转义”符号事实上是一些 LaTeX 命令。其中 <code class="language-plaintext highlighter-rouge">\^</code> 和 <code class="language-plaintext highlighter-rouge">\~</code> 两个命令需要一个参数，加一对花括号的写法相当于提供了空的参数，否则它们可能会将后面的字符作为参数，形成重音效果。<code class="language-plaintext highlighter-rouge">\\</code> 被直接定义成了手动换行的命令，输入反斜线就需要用 <code class="language-plaintext highlighter-rouge">\textbackslash</code>。</p> <p>西文排版中经常会出现连字(ligatures)，常见的有 <code class="language-plaintext highlighter-rouge">ff</code>/<code class="language-plaintext highlighter-rouge">fi</code>/<code class="language-plaintext highlighter-rouge">fl</code>/<code class="language-plaintext highlighter-rouge">ffi</code>/<code class="language-plaintext highlighter-rouge">ffl</code>。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It's difficult to find <span class="k">\ldots\\</span>
It's dif<span class="p">{}</span>f<span class="p">{}</span>icult to f<span class="p">{}</span>ind <span class="k">\ldots</span>
</code></pre></div></div> <p>LaTeX 中单引号 ‘ 和 ’ 分别用 ` 和 <code class="language-plaintext highlighter-rouge">'</code> 输入;双引号 “ 和 ” 分别用 `` 和 <code class="language-plaintext highlighter-rouge">''</code> 输入(<code class="language-plaintext highlighter-rouge">"</code> 可以输入后双引号，但没有直接输入前双引号的字符，习惯上用 <code class="language-plaintext highlighter-rouge">''</code> 输入以和 `` 更好地对应)。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>``Please press the `x' key.''
</code></pre></div></div> <p>LaTeX 中有三种长度的“横线”可用:连字号(hyphen)、短破折号(en-dash)和长破折号 (em-dash)。它们分别有不同的用途:连字号用来组成复合词;短破折号用来连接数字表示范围;长破折号用来连接单词，语义上类似中文的破折号。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>daughter-in-law, X-rated<span class="k">\\</span>
pages 13--67<span class="k">\\</span>
yes---or no?
</code></pre></div></div> <p>LaTeX 提供了 <code class="language-plaintext highlighter-rouge">\ldots</code> 命令表示省略号，相对于直接输入三个点的方式更为合理。<code class="language-plaintext highlighter-rouge">\dots</code> 与 <code class="language-plaintext highlighter-rouge">\ldots</code> 命令等效。</p> <h3 id="断行和断页">断行和断页</h3> <p>在西文排版实践中，断行的位置优先选取在两个单词之间，也就是在源代码中输入的“空格” 。“空格”本身通常生成一个间距，它会根据行宽和上下文自动调整，文字密一些的地方， 单词间距就略窄，反之略宽。</p> <p>文字在单词间的“空格”处断行时，“空格”生成的间距随之舍去。我们可以使用字符 <code class="language-plaintext highlighter-rouge">~</code> 输 入一个不会断行的空格(高德纳称之为 tie，“带子”)，通常用在英文人名、图表名称等上下文环境:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Fig.~2a <span class="k">\\</span>
Donald~E.~Knuth
</code></pre></div></div> <p>如果我们确实需要手动断行，可使用如下命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\\</span><span class="na">[⟨length⟩]</span>
<span class="k">\\*</span><span class="na">[⟨length⟩]</span>
<span class="k">\newline</span>
</code></pre></div></div> <p>它们有两点区别:一是 <code class="language-plaintext highlighter-rouge">\\</code> 可以带可选参数 <code class="language-plaintext highlighter-rouge">⟨length⟩</code>，用于在断行处向下增加垂直间距，而 <code class="language-plaintext highlighter-rouge">\newline</code> 不带可选参数;二是 <code class="language-plaintext highlighter-rouge">\\</code> 也在表格、公式等地方用于换行，而 <code class="language-plaintext highlighter-rouge">\newline</code> 只用于文本段落中。带星号的 <code class="language-plaintext highlighter-rouge">\\</code> 表示禁止在断行处分页。</p> <p>另外需要注意的是，使用 <code class="language-plaintext highlighter-rouge">\\</code> 断行命令 不会令内容另起一段，而是在段落中直接开始新的一行。</p> <p>断页的命令有两个：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\newpage</span>
<span class="k">\clearpage</span>
</code></pre></div></div> <p>通常情况下两个命令都起到另起一页的作用，区别在于:第一，在双栏排版模式中 <code class="language-plaintext highlighter-rouge">\newpage</code> 起到另起一栏的作用，<code class="language-plaintext highlighter-rouge">\clearpage</code> 则能够另起一页;第二，在涉及浮动体的排版上行为不同。</p> <h2 id="文档元素">文档元素</h2> <h3 id="章节和目录">章节和目录</h3> <p>一篇文档通过不同的命令分割为章、节、小节。三个标准文档类 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">report</code> 和 <code class="language-plaintext highlighter-rouge">book</code>提供了划分章节的命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\chapter</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\section</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\subsection</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\subsubsection</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\paragraph</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\subparagraph</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">\chapter</code> 只在 report 和 book 文档类有定义。这些命令生成章节标题，并能够自动编号。 除此之外 LaTeX 还提供了 <code class="language-plaintext highlighter-rouge">\part</code> 命令，用来将整个文档分割为大的分块，但不影响 \chapter 或 \section 等的编号。</p> <p>上述命令除了生成带编号的标题之外，还向目录中添加条目，并影响页眉页脚的内容。每个命令有两种变体:</p> <ul> <li>带可选参数的变体:<code class="language-plaintext highlighter-rouge">\section[⟨short title⟩]{⟨title⟩}</code><br/> 标题使用 <code class="language-plaintext highlighter-rouge">⟨title⟩</code> 参数，在目录和页眉页脚中使用 <code class="language-plaintext highlighter-rouge">⟨short title⟩</code> 参数；</li> <li>带星号的变体:<code class="language-plaintext highlighter-rouge">\section*{⟨title⟩}</code><br/> 标题不带编号，也不生成目录项和页眉页脚。</li> </ul> <p>较低层次如 <code class="language-plaintext highlighter-rouge">\paragraph</code> 和 <code class="language-plaintext highlighter-rouge">\subparagraph</code> 即使不用带星号的变体，生成的标题默认也不带编号，事实上，除 <code class="language-plaintext highlighter-rouge">\part</code> 外:</p> <ul> <li><code class="language-plaintext highlighter-rouge">article</code> 文档类带编号的层级为 <code class="language-plaintext highlighter-rouge">\section</code>、<code class="language-plaintext highlighter-rouge">\subsection</code>、<code class="language-plaintext highlighter-rouge">\subsubsection</code> 三级；</li> <li><code class="language-plaintext highlighter-rouge">report</code> 和 <code class="language-plaintext highlighter-rouge">book</code> 文档类带编号的层级为 <code class="language-plaintext highlighter-rouge">\chapter</code>、<code class="language-plaintext highlighter-rouge">\section</code>、<code class="language-plaintext highlighter-rouge">\subsection</code> 三级。</li> </ul> <p>LaTeX 及标准文档类并未提供为 \section 等章节命令定制格式的功能，这一功能由 <code class="language-plaintext highlighter-rouge">titlesec</code>宏包提供。</p> <h3 id="目录">目录</h3> <p>在 LateX 中生成目录非常容易，只需在合适的地方使用命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\tableofcontents</span>
</code></pre></div></div> <p>这个命令会生成单独的一章(report/book)或一节(article)，标题默认为“Contents”。\tableofcontents 生成的章节默认不写入目录(\section* 或 \chapter*)，可使用 <code class="language-plaintext highlighter-rouge">tocbibind</code> 等宏包修改设置。</p> <p>正确生成目录项，一般需要编译两次源代码。</p> <p>有时我们使用了 \chapter* 或 \section* 这样不生成目录项的章节标题命令，而又想手动生成该章节的目录项，可以在标题命令后面使用:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\addcontentsline</span><span class="p">{</span>toc<span class="p">}{</span>⟨level⟩<span class="p">}{</span>⟨title⟩<span class="p">}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">⟨level⟩</code> 为章节层次 chapter 或 section 等，<code class="language-plaintext highlighter-rouge">⟨title⟩</code> 为出现于目录项的章节标题。</p> <p><code class="language-plaintext highlighter-rouge">titletoc</code>、<code class="language-plaintext highlighter-rouge">tocloft</code> 等宏包提供了具体定制目录项格式的功能。</p> <h3 id="文档结构的划分">文档结构的划分</h3> <p>所有标准文档类都提供了一个 <code class="language-plaintext highlighter-rouge">\appendix</code> 命令将正文和附录分开，使用 <code class="language-plaintext highlighter-rouge">\appendix</code> 后，最高一级章节改为使用拉丁字母编号，从 A 开始。</p> <p>book 文档类还提供了前言、正文、后记结构的划分命令:</p> <p><code class="language-plaintext highlighter-rouge">\frontmatter</code> 前言部分，页码使用小写罗马数字;其后的 \chapter 不编号。</p> <p><code class="language-plaintext highlighter-rouge">\mainmatter</code> 正文部分，页码使用阿拉伯数字，从 1 开始计数;其后的章节编号正常。</p> <p><code class="language-plaintext highlighter-rouge">\backmatter</code> 后记部分，页码格式不变，继续正常计数;其后的 \chapter 不编号。</p> <p>以上三个命令还可和 <code class="language-plaintext highlighter-rouge">\appendix</code> 命令结合，生成有前言、正文、附录、后记四部分的文档。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>book<span class="p">}</span>

<span class="c">% 导言区，加载宏包和各项设置，包括参考文献、索引等</span>
<span class="k">\usepackage</span><span class="p">{</span>makeidx<span class="p">}</span>    <span class="c">% 调用 makeidx 宏包，用来处理索引 </span>
<span class="k">\makeindex</span>  <span class="c">% 开启索引的收集</span>
<span class="k">\bibliographystyle</span><span class="p">{</span>plain<span class="p">}</span>   <span class="c">% 指定参考文献样式为 plain</span>

<span class="nt">\begin{document}</span>

<span class="k">\frontmatter</span>    <span class="c">% 前言部分</span>
<span class="k">\maketitle</span>  <span class="c">% 标题页</span>
<span class="k">\include</span><span class="p">{</span>preface<span class="p">}</span>   <span class="c">% 前言章节 preface.tex</span>
<span class="k">\tableofcontents</span>

<span class="k">\mainmatter</span> <span class="c">% 正文部分</span>
<span class="k">\include</span><span class="p">{</span>chapter1<span class="p">}</span>  <span class="c">% 第一章 chapter1.tex</span>
<span class="k">\include</span><span class="p">{</span>chapter2<span class="p">}</span>  <span class="c">% 第二章 chapter2.tex</span>
...
<span class="k">\appendix</span>   <span class="c">% 附录</span>
<span class="k">\include</span><span class="p">{</span>appendixA<span class="p">}</span> <span class="c">% 附录 A appendixA.tex</span>
...

<span class="k">\backmatter</span> <span class="c">% 后记部分</span>
<span class="k">\include</span><span class="p">{</span>epilogue<span class="p">}</span>  <span class="c">% 后记 epilogue.tex</span>
<span class="k">\bibliography</span><span class="p">{</span>books<span class="p">}</span>    <span class="c">% 利用 BibTeX 工具从数据库文件 books.bib 生成参考文献</span>
<span class="k">\printindex</span> <span class="c">% 利用 makeindex 工具生成索引</span>

<span class="nt">\end{document}</span>
</code></pre></div></div> <h3 id="标题页">标题页</h3> <p>LaTeX 支持生成简单的标题页。首先需要给定标题和作者等信息:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\title</span><span class="p">{</span>⟨title⟩<span class="p">}</span> <span class="k">\author</span><span class="p">{</span>⟨author ⟩<span class="p">}</span> <span class="k">\date</span><span class="p">{</span>⟨date⟩<span class="p">}</span>
</code></pre></div></div> <p>其中前两个命令是必须的(不用 <code class="language-plaintext highlighter-rouge">\title</code> 会报错;不用 <code class="language-plaintext highlighter-rouge">\author</code> 会警告)，<code class="language-plaintext highlighter-rouge">\date</code> 命令可选。LaTeX 还提供了一个 <code class="language-plaintext highlighter-rouge">\today</code> 命令自动生成当前日期，<code class="language-plaintext highlighter-rouge">\date</code> 默认使用 <code class="language-plaintext highlighter-rouge">\today</code>。在 <code class="language-plaintext highlighter-rouge">\title</code>、<code class="language-plaintext highlighter-rouge">\author</code> 等命令内可以使用 <code class="language-plaintext highlighter-rouge">\thanks</code> 命令生成标题页的脚注，用 <code class="language-plaintext highlighter-rouge">\and</code> 隔开多个人名。在信息给定后，就可以使用 <code class="language-plaintext highlighter-rouge">\maketitle</code> 命令生成一个简单的标题页了。</p> <p>article 文档类的标题默认不单独成页，而 report 和 book 默认单 独成页。可在 <code class="language-plaintext highlighter-rouge">\documentclass</code> 命令调用文档类时指定 <code class="language-plaintext highlighter-rouge">titlepage</code> 或 <code class="language-plaintext highlighter-rouge">notitlepage</code> 选项以修改默认的行为。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\title</span><span class="p">{</span>Test title<span class="p">}</span>
<span class="k">\author</span><span class="p">{</span> Mary<span class="k">\thanks</span><span class="p">{</span>E-mail:*****@***.com<span class="p">}</span>
  <span class="k">\and</span> Ted<span class="k">\thanks</span><span class="p">{</span>Corresponding author<span class="p">}</span>
  <span class="k">\and</span> Louis<span class="p">}</span>
<span class="k">\date</span><span class="p">{</span><span class="k">\today</span><span class="p">}</span>
</code></pre></div></div> <p>LaTeX 标准类还提供了一个简单的 titlepage 环境，生成不带页眉页脚的一页。用户可以 在这个环境中使用各种排版元素自由发挥，生成自定义的标题页以替代 \maketitle 命令。甚至 可以利用 titlepage 环境重新定义 \maketitle:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\renewcommand</span><span class="p">{</span><span class="k">\maketitle</span><span class="p">}{</span>
    <span class="nt">\begin{titlepage}</span>
    ... <span class="c">% 用户自定义命令</span>
    <span class="nt">\end{titlepage}</span>
<span class="p">}</span>
</code></pre></div></div> <p>事实上，为标准文档类指定了 titlepage 选项以后，使用 \maketitle 命令生成的标题页 就是一个 titlepage 环境。</p> <p>以上是 LaTeX 标准文档类的标题页相关命令用法。在各种文档模板中经常有自定义的标题 页，有可能需要除了 \title 和 \author 以外的命令给定信息，用法也可能与标准文档类的不一致(甚至有些模板可能没有定义 titlepage 等环境)。使用文档模板前一定要仔细阅读文档模板的帮助文档。</p> <h3 id="交叉引用">交叉引用</h3> <p>交叉引用是 LaTeX 强大的自动排版功能的体现之一。在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用 <code class="language-plaintext highlighter-rouge">\label</code> 命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\label</span><span class="p">{</span>⟨label-name⟩<span class="p">}</span>
</code></pre></div></div> <p>之后可以在别处使用 <code class="language-plaintext highlighter-rouge">\ref</code> 或 <code class="language-plaintext highlighter-rouge">\pageref</code> 命令，分别生成交叉引用的编号和页码:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\ref</span><span class="p">{</span>⟨label-name⟩<span class="p">}</span> <span class="k">\pageref</span><span class="p">{</span>⟨label-name⟩<span class="p">}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A reference to this subsection
<span class="k">\label</span><span class="p">{</span>sec:this<span class="p">}</span> looks like:

``see section~<span class="k">\ref</span><span class="p">{</span>sec:this<span class="p">}</span> on
page~<span class="k">\pageref</span><span class="p">{</span>sec:this<span class="p">}</span>.''
</code></pre></div></div> <p>为了生成正确的交叉引用，一般也需要多次编译源代码。</p> <p><code class="language-plaintext highlighter-rouge">\label</code> 命令可用于记录各种类型的交叉引用，使用位置分别为:</p> <ul> <li><strong>章节标题</strong> 在章节标题命令 <code class="language-plaintext highlighter-rouge">\section</code> 等之后紧接着使用。</li> <li><strong>行间公式</strong> 单行公式在公式内任意位置使用;多行公式在每一行公式的任意位置使用。 有序列表 在 <code class="language-plaintext highlighter-rouge">enumerate</code> 环境的每个 <code class="language-plaintext highlighter-rouge">\item</code> 命令之后、下一个 <code class="language-plaintext highlighter-rouge">\item</code> 命令之前任意位置使用。 图表标题在图表标题命令 <code class="language-plaintext highlighter-rouge">\caption</code> 之后紧接着使用。</li> <li><strong>定理环境</strong> 在定理环境内部任意位置使用。</li> </ul> <p>在使用不记编号的命令形式(<code class="language-plaintext highlighter-rouge">\section*</code>、<code class="language-plaintext highlighter-rouge">\caption*</code>、带可选参数的 <code class="language-plaintext highlighter-rouge">\item</code> 命令等)时不要使用 <code class="language-plaintext highlighter-rouge">\label</code> 命令，否则生成的引用编号不正确。</p> <h3 id="脚注和边注">脚注和边注</h3> <p>使用 <code class="language-plaintext highlighter-rouge">\footnote</code> 命令可以在页面底部生成一个脚注:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\footnote</span><span class="p">{</span>⟨footnote⟩<span class="p">}</span>
</code></pre></div></div> <p>有些情况下(比如在表格环境、各种盒子内)使用 <code class="language-plaintext highlighter-rouge">\footnote</code> 并不能正确生成脚注。我们可以分两步进行，先使用 <code class="language-plaintext highlighter-rouge">\footnotemark</code> 为脚注计数，再在合适的位置用 <code class="language-plaintext highlighter-rouge">\footnotetext</code> 生成 脚注。比如:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{tabular}</span><span class="p">{</span>l<span class="p">}</span>
<span class="k">\hline</span> “天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。”<span class="k">\footnotemark</span> <span class="k">\\</span> <span class="k">\hline</span>
<span class="nt">\end{tabular}</span>
<span class="k">\footnotetext</span><span class="p">{</span>表格里的名句出自《千字文》。<span class="p">}</span>
</code></pre></div></div> <p>使用 <code class="language-plaintext highlighter-rouge">\marginpar</code> 命令可在边栏位置生成边注:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\marginpar</span><span class="na">[⟨left-margin⟩]</span><span class="p">{</span>⟨right-margin⟩<span class="p">}</span>
</code></pre></div></div> <p>如果只给定了 <code class="language-plaintext highlighter-rouge">⟨right-margin⟩</code>，那么边注在奇偶数页文字相同;如果同时给定了 <code class="language-plaintext highlighter-rouge">⟨left-margin⟩</code>，则 偶数页使用 <code class="language-plaintext highlighter-rouge">⟨left-margin⟩</code> 的文字。</p> <h3 id="列表">列表</h3> <p>LaTeX 提供了基本的有序和无序列表环境 <code class="language-plaintext highlighter-rouge">enumerate</code> 和 <code class="language-plaintext highlighter-rouge">itemize</code> ，两者的用法都很类似，都用 <code class="language-plaintext highlighter-rouge">\item</code> 标明每个列表项。<code class="language-plaintext highlighter-rouge">enumerate</code> 环境会自动对列表项编号。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{enumerate}</span> <span class="k">\item</span> ... <span class="nt">\end{enumerate}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">\item</code> 可带一个可选参数，将有序列表的计数或者无序列表的符号替换成自定义的符号。列表可以嵌套使用，最多嵌套四层。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{enumerate}</span>
  <span class="k">\item</span> An item.
  <span class="nt">\begin{enumerate}</span>
    <span class="k">\item</span> A nested item.<span class="k">\label</span><span class="p">{</span>itref<span class="p">}</span>
    <span class="k">\item</span><span class="na">[*]</span> A starred item.
  <span class="nt">\end{enumerate}</span>
  <span class="k">\item</span> Reference(<span class="k">\ref</span><span class="p">{</span>itref<span class="p">}</span>).
<span class="nt">\end{enumerate}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{itemize}</span>
  <span class="k">\item</span> An item.
  <span class="nt">\begin{itemize}</span>
    <span class="k">\item</span> A nested item.
    <span class="k">\item</span><span class="na">[+]</span> A `plus' item.
    <span class="k">\item</span> Another item.
  <span class="nt">\end{itemize}</span>
  <span class="k">\item</span> Go back to upper level.
<span class="nt">\end{itemize}</span>
</code></pre></div></div> <p>关键字环境 <code class="language-plaintext highlighter-rouge">description</code> 的用法与以上两者类似，不同的是<code class="language-plaintext highlighter-rouge">\item</code> 后的可选参数用来写关键字，以粗体显示，一般是必填的:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{description}</span> 
  <span class="k">\item</span><span class="na">[⟨item title⟩]</span> ... 
<span class="nt">\end{description}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{description}</span>
  <span class="k">\item</span><span class="na">[Enumerate]</span> Numbered list.
  <span class="k">\item</span><span class="na">[Itemize]</span> Non-numbered list.
<span class="nt">\end{description}</span>
</code></pre></div></div> <p>各级无序列表的符号由命令 <code class="language-plaintext highlighter-rouge">\labelitemi</code> 到 <code class="language-plaintext highlighter-rouge">\labelitemiv</code> 定义，可以简单地重新定义它们:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\renewcommand</span><span class="p">{</span><span class="k">\labelitemi</span><span class="p">}{</span><span class="k">\ddag</span><span class="p">}</span>
<span class="k">\renewcommand</span><span class="p">{</span><span class="k">\labelitemii</span><span class="p">}{</span><span class="k">\dag</span><span class="p">}</span>
<span class="nt">\begin{itemize}</span>
  <span class="k">\item</span> First item
  <span class="nt">\begin{itemize}</span>
    <span class="k">\item</span> Subitem
    <span class="k">\item</span> Subitem
  <span class="nt">\end{itemize}</span>
  <span class="k">\item</span> Second item
<span class="nt">\end{itemize}</span>
</code></pre></div></div> <p>有序列表的符号由命令 <code class="language-plaintext highlighter-rouge">\labelenumi</code> 到 <code class="language-plaintext highlighter-rouge">\labelenumiv</code> 定义，重新定义这些命令需要用到计数器相关命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\renewcommand</span><span class="p">{</span><span class="k">\labelenumi</span><span class="p">}</span><span class="c">%</span>
  <span class="p">{</span><span class="k">\Alph</span><span class="p">{</span>enumi<span class="p">}</span>&gt;<span class="p">}</span>
<span class="nt">\begin{enumerate}</span>
  <span class="k">\item</span> First item
  <span class="k">\item</span> Second item
<span class="nt">\end{enumerate}</span>
</code></pre></div></div> <p>默认的列表间距比较宽，LaTeX 本身也未提供方便的定制功能，可用 <code class="language-plaintext highlighter-rouge">enumitem</code> 宏包定制各种列表间距。<code class="language-plaintext highlighter-rouge">enumitem</code> 宏包还提供了对列表标签、引用等的定制。有兴趣的读者可参考其帮助文档。</p> <h3 id="对齐环境">对齐环境</h3> <p><code class="language-plaintext highlighter-rouge">center</code>、<code class="language-plaintext highlighter-rouge">flushleft</code> 和 <code class="language-plaintext highlighter-rouge">flushright</code> 环境分别用于生成居中、左对齐和右对齐的文本环境。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{center}</span> ... <span class="nt">\end{center}</span>
<span class="nt">\begin{flushleft}</span> ... <span class="nt">\end{flushleft}</span>
<span class="nt">\begin{flushright}</span> ... <span class="nt">\end{flushright}</span>
</code></pre></div></div> <p>除此之外，还可以用以下命令直接改变文字的对齐方式:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\centering</span> <span class="k">\raggedright</span> <span class="k">\raggedleft</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\centering</span>
Centered text paragraph.
<span class="k">\raggedright</span>
Left-aligned text paragraph.
<span class="k">\raggedleft</span>
Right-aligned text paragraph.
</code></pre></div></div> <p>三个命令和对应的环境经常被误用，有直接用所谓 <code class="language-plaintext highlighter-rouge">\flushleft</code> 命令或者 <code class="language-plaintext highlighter-rouge">raggedright</code> 环境的，都是不甚严格的用法(即使它们可能有效)。有一点可以将两者区分开来:<code class="language-plaintext highlighter-rouge">center</code> 等环境会在上下文产生一个额外间距，而 <code class="language-plaintext highlighter-rouge">\centering</code> 等命令不产生，只是改变对齐方式。比如在浮动 体环境 <code class="language-plaintext highlighter-rouge">table</code> 或 <code class="language-plaintext highlighter-rouge">figure</code> 内实现居中对齐，用 <code class="language-plaintext highlighter-rouge">\centering</code> 命令即可，没必要再用 <code class="language-plaintext highlighter-rouge">center</code> 环境。</p> <h3 id="引用环境">引用环境</h3> <p>LaTeX 提供了两种引用的环境:<code class="language-plaintext highlighter-rouge">quote</code> 用于引用较短的文字，首行不缩进;<code class="language-plaintext highlighter-rouge">quotation</code> 用于引用若干段文字，首行缩进。引用环境较一般文字有额外的左右缩进。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Francis Bacon says:
<span class="nt">\begin{quote}</span>
Knowledge is power.
<span class="nt">\end{quote}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>《木兰诗》:
<span class="nt">\begin{quotation}</span>
万里赴戎机，关山度若飞。
朔气传金柝，寒光照铁衣。
将军百战死，壮士十年归。

归来见天子，天子坐明堂。
策勋十二转，赏赐百千强。⋯⋯ 
<span class="nt">\end{quotation}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">verse</code> 用于排版诗歌，与 <code class="language-plaintext highlighter-rouge">quotation</code> 恰好相反，<code class="language-plaintext highlighter-rouge">verse</code> 是首行悬挂缩进的。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rabindranath Tagore's short poem:
<span class="nt">\begin{verse}</span>
Beauty is truth's smile
when she beholds her own face in
a perfect mirror.
<span class="nt">\end{verse}</span>
</code></pre></div></div> <h3 id="摘要环境">摘要环境</h3> <p>摘要环境 <code class="language-plaintext highlighter-rouge">abstract</code> 默认只在标准文档类中的 <code class="language-plaintext highlighter-rouge">article</code> 和 <code class="language-plaintext highlighter-rouge">report</code> 文档类可用，一般用于紧跟 <code class="language-plaintext highlighter-rouge">\maketitle</code> 命令之后介绍文档的摘要。如果文档类指定了 <code class="language-plaintext highlighter-rouge">titlepage</code> 选项，则单独成页;反之， 单栏排版时相当于一个居中的小标题加一个 <code class="language-plaintext highlighter-rouge">quotation</code> 环境，双栏排版时相当于 <code class="language-plaintext highlighter-rouge">\section*</code> 定义的一节。</p> <h3 id="代码环境">代码环境</h3> <p>有时我们需要将一段代码原样转义输出，这就要用到代码环境 <code class="language-plaintext highlighter-rouge">verbatim</code>，它以等宽字体排版代码，回车和空格也分别起到换行和空位的作用;带星号的版本更进一步将空格显示成“␣”。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{verbatim}</span>
#include &lt;iostream&gt;
int main()
<span class="p">{</span>
  std::cout &lt;&lt; "Hello, world!"
            &lt;&lt; std::endl;
return 0; <span class="p">}</span>
<span class="nt">\end{verbatim}</span>

<span class="p">{</span>verbatim*<span class="p">}</span>
for (int i=0; i&lt;4; ++i)
  printf("Number <span class="c">%d\n",i);</span>
<span class="nt">\end{verbatim*}</span>
</code></pre></div></div> <p>要排版简短的代码或关键字，可使用 <code class="language-plaintext highlighter-rouge">\verb</code> 命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">\verb</span><span class="kp">⟨</span><span class="sx">delim⟩</span><span class="kp">⟨</span>code⟩⟨delim⟩
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">⟨delim⟩</code> 标明代码的分界位置，前后必须一致，除字母、空格或星号外，可任意选择使得不与代码本身冲突，习惯上使用 <code class="language-plaintext highlighter-rouge">|</code> 符号。</p> <p>同 <code class="language-plaintext highlighter-rouge">verbatim</code> 环境，<code class="language-plaintext highlighter-rouge">\verb</code> 后也可以带一个星号，以显示空格:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">\verb</span><span class="kp">|</span><span class="sx">\LaTeX</span><span class="kp">|</span><span class="k">\\</span>
<span class="nb">\verb</span><span class="kp">+</span><span class="sx">(a || b)</span><span class="kp">+</span> <span class="k">\verb*</span>+(a || b)+
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">\verb</code> 命令对符号的处理比较复杂，一般不能用在其它命令的参数里，否则多半会出错。</p> <p><code class="language-plaintext highlighter-rouge">verbatim</code> 宏包优化了 <code class="language-plaintext highlighter-rouge">verbatim</code> 环境的内部命令，并提供了 <code class="language-plaintext highlighter-rouge">\verbatiminput</code> 命令用来直接 读入文件生成代码环境。<code class="language-plaintext highlighter-rouge">fancyvrb</code> 宏包提供了可定制格式的 <code class="language-plaintext highlighter-rouge">Verbatim</code> 环境;<code class="language-plaintext highlighter-rouge">listings</code> 宏包更进一步，可生成关键字高亮的代码环境，支持各种程序设计语言的语法和关键字。详情请参考各自的帮助文档。</p> <h3 id="表格">表格</h3> <p>排版表格最基本的 <code class="language-plaintext highlighter-rouge">tabular</code> 环境用法为:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{tabular}</span>[&lt;align&gt;]<span class="p">{</span>&lt;column-spec&gt;<span class="p">}</span>
&lt;item1&gt; <span class="p">&amp;</span> &lt;item2&gt; <span class="p">&amp;</span> ... <span class="k">\\</span>
<span class="k">\hline</span>
&lt;item1&gt; <span class="p">&amp;</span> &lt;item2&gt; <span class="p">&amp;</span> ... <span class="k">\\</span>
<span class="nt">\end{tabular}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">⟨column-spec⟩</code> 是列格式标记，在接下来的内容将仔细介绍;<code class="language-plaintext highlighter-rouge">&amp;</code> 用来分隔单元格;<code class="language-plaintext highlighter-rouge">\\</code> 用来换行;<code class="language-plaintext highlighter-rouge">\hline</code> 用来在行与行之间绘制横线。</p> <p>直接使用 <code class="language-plaintext highlighter-rouge">tabular</code> 环境的话，会<strong>和周围的文字混排</strong>。此时可用一个可选参数 <code class="language-plaintext highlighter-rouge">⟨align⟩</code> 控制垂 直对齐:<code class="language-plaintext highlighter-rouge">t</code> 和 <code class="language-plaintext highlighter-rouge">b</code> 分别表示按表格顶部、底部对齐，其他参数或省略不写(默认)表示居中对齐。</p> <p>但是通常情况下 <code class="language-plaintext highlighter-rouge">tabular</code> 环境很少与文字直接混排，而是会放在 <code class="language-plaintext highlighter-rouge">table</code> 浮动体环境中，并用 <code class="language-plaintext highlighter-rouge">\caption</code> 命令加标题。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[LaTeX 的基本概念]]></summary></entry><entry><title type="html">Ubuntu 22.04 安装 MySQL</title><link href="https://jkfx.github.io/blog/2022/Ubuntu-22.04-%E5%AE%89%E8%A3%85-MySQL/" rel="alternate" type="text/html" title="Ubuntu 22.04 安装 MySQL"/><published>2022-10-27T21:39:00+00:00</published><updated>2022-10-27T21:39:00+00:00</updated><id>https://jkfx.github.io/blog/2022/Ubuntu%2022.04%20%E5%AE%89%E8%A3%85%20MySQL</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/Ubuntu-22.04-%E5%AE%89%E8%A3%85-MySQL/"><![CDATA[<p>本文记录了在 Ubuntu 22.04 下安装 MySQL 8.0 和 5.7 版本的步骤。</p> <h2 id="下载文件">下载文件</h2> <p>在 <a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a> 发行地址中选择 <code class="language-plaintext highlighter-rouge">Linux - Generic</code> 操作系统，选择对应的 MySQL 版本后，下载 MySQL 的压缩包。</p> <p>本文下载的 8.0.30 以及 5.7.39 版本。</p> <h2 id="安装-mysql-57--80">安装 MySQL 5.7 / 8.0</h2> <p>以管理员权限添加 <code class="language-plaintext highlighter-rouge">mysql</code> 的组以及用户。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> groupadd mysql
<span class="nv">$&gt;</span> useradd <span class="nt">-r</span> <span class="nt">-g</span> mysql <span class="nt">-s</span> /bin/false mysql
</code></pre></div></div> <p>之后进入到 <code class="language-plaintext highlighter-rouge">/usr/local</code> 目录中，将下载好的压缩包解压到该目录，并且建立一个符号链接对应到解压缩出的文件目录，之后创建必需文件夹以及给目录授权。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local
<span class="nv">$&gt;</span> <span class="nb">tar </span>xvf /压缩文件目录/mysql-VERSION-OS.tar.xz
<span class="nv">$&gt;</span> <span class="nb">ln</span> <span class="nt">-s</span> mysql-VERSION-OS mysql
<span class="nv">$&gt;</span> <span class="nb">cd </span>mysql
<span class="nv">$&gt;</span> <span class="nb">mkdir </span>mysql-files
<span class="nv">$&gt;</span> <span class="nb">chown </span>mysql:mysql mysql-files
<span class="nv">$&gt;</span> <span class="nb">chmod </span>750 mysql-files
</code></pre></div></div> <blockquote> <p>如果提示权限不够在命令前面加 <code class="language-plaintext highlighter-rouge">sudo</code> 使用管理员账户执行。</p> </blockquote> <p>将 <code class="language-plaintext highlighter-rouge">mysql</code> 目录添加到环境变量中，以便可以在终端中执行 MySQL 执行文件。可以选择添加到 <code class="language-plaintext highlighter-rouge">/etc/profile</code> 系统环境变量的文件中。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/local/mysql/bin
</code></pre></div></div> <p>之后进入到 <code class="language-plaintext highlighter-rouge">/usr/local/mysql</code> 目录中，执行 MySQL 的初始化命令。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local/mysql
<span class="nv">$&gt;</span> bin/mysqld <span class="nt">--initialize</span> <span class="nt">--user</span><span class="o">=</span>mysql
<span class="c"># 或者执行 bin/mysqld --initialize-insecure --user=mysql</span>
<span class="c"># --initialize 表明初始化 MySQL 时给 root 账户设一个随机值组成的初始密码</span>
<span class="c"># --initialize-insecure 表明初始化 MySQL 时给 root 账户设一个空密码</span>
<span class="c"># 如果当前终端执行 mysqld 的账户是 mysql 也可以忽略 --user=mysql</span>
</code></pre></div></div> <p>初始化成功之后进入到 <code class="language-plaintext highlighter-rouge">mysql</code> 环境中，给 <code class="language-plaintext highlighter-rouge">root</code> 账户重新设置一个密码。</p> <p>如果使用 <code class="language-plaintext highlighter-rouge">--initialize</code> 命令，注意终端输出中 <code class="language-plaintext highlighter-rouge">root</code> 的初始随机密码，下面登录使用。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 使用 --initialize</span>
<span class="nv">$&gt;</span> mysql <span class="nt">-u</span> root <span class="nt">-p</span>
<span class="c"># 输入密码登录</span>

<span class="c"># 使用 --initialize-insecure</span>
<span class="nv">$&gt;</span> mysql <span class="nt">-u</span> root <span class="nt">--skip-password</span>
</code></pre></div></div> <blockquote> <p>如果显示无法连接，可能是没启动 MySQL 服务，执行下面语句开启 MySQL 服务。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local/mysql/support-files
<span class="nv">$&gt;</span> ./mysql.server start
</code></pre></div> </div> </blockquote> <p>进入到 MySQL 环境后，执行 SQL 语句修改 <code class="language-plaintext highlighter-rouge">root</code> 账号密码。</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="err">修改</span> <span class="n">root</span> <span class="err">账号密码</span>
<span class="k">ALTER</span> <span class="k">USER</span> <span class="s1">'root'</span><span class="o">@</span><span class="s1">'localhost'</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">'root-password'</span><span class="p">;</span>
</code></pre></div></div> <h2 id="设置-mysql-服务自动运行">设置 MySQL 服务自动运行</h2> <p>进入到 MySQL 的安装目录，复制支持文件到系统启动脚本目录中，并设置默认运行级别。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local/mysql/support-files
<span class="nv">$&gt;</span> <span class="nb">cp </span>mysql.server /etc/init.d/mysql
<span class="nv">$&gt;</span> <span class="nb">chmod</span> +x /etc/init.d/mysql
<span class="nv">$&gt;</span> update-rc.d mysql defaults
</code></pre></div></div> <p>注销或者重启， MySQL 服务已经自动启动。</p> <blockquote> <p>如果需要在 5.7 和 8.0 版本之间切换，以同样的步骤执行 MySQL 的初始化命令，将 <code class="language-plaintext highlighter-rouge">/usr/local/mysql</code> 这个符号链接替换为对应的版本目录即可。</p> </blockquote>]]></content><author><name></name></author><summary type="html"><![CDATA[本文记录了在 Ubuntu 22.04 下安装 MySQL 8.0 和 5.7 版本的步骤。]]></summary></entry><entry><title type="html">Clean Architecture</title><link href="https://jkfx.github.io/blog/2022/Clean-Architecture/" rel="alternate" type="text/html" title="Clean Architecture"/><published>2022-07-16T19:41:00+00:00</published><updated>2022-07-16T19:41:00+00:00</updated><id>https://jkfx.github.io/blog/2022/Clean%20Architecture</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/Clean-Architecture/"><![CDATA[<blockquote> <p>by Robert C. Martin (Uncle Bob)<br/> 13 August 2012<br/> <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p> </blockquote> <p><img src="https://tva2.sinaimg.cn/large/006VTcCxly1h48ouqtk4uj30lg0frjxl.jpg" alt="image"/></p> <p>在过去的几十年间，我们已经看到了一系列的关于系统架构的想法。其中包括：</p> <ul> <li><a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal Architecture</a> （也叫 <em>Ports and Adapters</em>）在 <a href="http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627">Growing Object Oriented Software</a> 一书中有着描述</li> <li><a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/">Onion Architecture</a></li> <li><a href="http://blog.cleancoders.com/2011-09-30-Screaming-Architecture">Screaming Architecture</a></li> <li><a href="http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/">DCI</a></li> <li><a href="http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350">BCE</a> 在 <em>Object Oriented Software Engineering: A Use-Case Driven Approach</em> 一书</li> </ul> <p>尽管这些架构在细节上都有着不同之处，它们都是非常相似的。它们都有一个目标，那就是 <strong>关注点分离</strong>（<em>the separation of concerns</em>）。它们通过将软件进行分层实现了这一分离。每一个架构都至少有一层是关于业务规则的，并且另一个是关于接口的处理。</p> <p>这些架构都产生了这样的系统：</p> <ol> <li>独立于框架。这些架构都没有依赖于已存在功能丰富的一些库。这使得你可以使用这些框架作为工具，而不是将你的系统塞进到它们的有限的约束中。</li> <li>可测试性。在没有UI 、数据库、Web 服务器以及其它任何外部元素的情况下,业务逻辑可以被测试。</li> <li>独立于 UI。UI 可以被轻易改变，并且无需影响系统中其它部分。例如，Web UI 可以被替换为终端 UI ，无需改变任何业务规则。</li> <li>独立于数据库。你可以使用 Mongo，BigTable，CouchDB或其它数据库换掉 Oracle 或 SQL Server。你的业务逻辑不受限在数据库中。</li> <li>独立于任何外部机构。事实上，你的业务逻辑根本不了解外部世界。</li> </ol> <p>本篇文章顶部的图片是整合这些架构到一个可行的想法的一个尝试。</p> <h2 id="the-dependency-rule">The Dependency Rule</h2> <blockquote> <p>依赖规则</p> </blockquote> <p>同心圆代表了软件的不同范围。通常来讲，你走的越远，软件就变成了更高的层次。外面的圆是机制（<em>mechanisms</em>），内部的圆是政策（<em>policies</em>）。</p> <p>使得架构运作凌驾一切的规则就是 <strong>依赖规则</strong>（<em>The Dependency Rule</em>）。这一规则说明了：源码中的依赖仅可以指向内部。内部的圆中不允许知道关于外部圆中的任何事物。尤其是一些声明在外部圆中的名称决不允许在内部圆中提及。其中包括：函数、类、变量或其它任何命名的软件实体。</p> <p>出于同样的原因，用在外部圆中的数据格式也不应该被用在内部圆中，尤其是当这些格式是被框架在外部圆中生成出来的时候。我们不想在外部圆中的任何事物影响到内部圆。</p> <h3 id="entities">Entities</h3> <blockquote> <p>实体</p> </blockquote> <p>实体封装了企业范围的业务规则。一个实体可以是带有方法的对象，或者也可以是数据结构和函数的集合。无关紧要的是只要实体可以被企业中许多不同的应用使用即可。</p> <p>如果你并没有一个企业，并且只是单纯的想写一个单一的应用，那么这些实体都是应用的业务对象。它们封装了最通用并且高阶的规则。当外部某些事物改变时，它们是最不可能被改变的。例如，你不会期待这些对象被外部页面导航栏或者安全性的改变而受到影响。任何特定的应用的操作性的改变都不会影响到实体层。</p> <h2 id="use-cases">Use Cases</h2> <blockquote> <p>用例</p> </blockquote> <p>软件中这一层包含了特定的应用业务规则。它封装并实现了系统中所有的用例。这些用例协调了进出实体的数据流，并且指导这些实体到使用它们企业范围业务规则用来实现用例的目标。</p> <p>我们并不期待对这一层的改变影响实体。我们也不期待这一层被外部的改变而受到影响，例如数据库、UI或其它任何常见的普遍框架。这一层与此类问题隔离。</p> <p>但是，我们确实期待应用的操作改变将会影响用例层，并且从而因影响这一层中的软件。如果用例层改变的细节，那么在这一层的某些代码将肯定收到影响。</p> <h2 id="interface-adapters">Interface Adapters</h2> <blockquote> <p>接口适配器</p> </blockquote> <p>在这一层的软件是一个适配器（<em>adapters</em>）的集合，适配器用来将数据从最方便用于用例层和实体层的格式，转换到最方便用于某些外部机构例如数据库或Web的格式。例如，正是这一层整个包含了GUI中的MVC架构。Presenters、VIews和Controllers全部属于这层。模型可只是从controllers传入到用例层的数据结构，并且之后从用例层返回到presenters和views。</p> <p>相似地是，在这一层，数据从最方便用于实体层和用例层的形式，被转换到最方便用于任何一个正在使用的持久框架的形式。这一层的圆中的代码不应该知道任何关于数据库的一切事物。如果数据库是一个SQL数据库，那么所有的SQL应该被限制到这一层，并且尤其是必须限制在这一层与数据库交互的部分。</p> <p>在这一层中还有任何其他适配器，用于将数据从某种外部形式（例如外部服务）转换为用例和实体使用的内部形式。</p> <h2 id="frameworks-and-drivers">Frameworks and Drivers</h2> <blockquote> <p>框架和驱动</p> </blockquote> <p>最外层通常是由框架和工具的组成，例如数据库和 Web 框架等等。通常来说，你不需要在这一层编写太多的代码，而是编写与下一圆圈交互的胶水语言。</p> <p>这一层是所有细节（<em>details</em>）的所在。Web 是一个细节。数据库也是一个细节。我们保持这些事物放在外部，它们不会造成任何破坏。</p> <h2 id="only-four-circles">Only Four Circles?</h2> <blockquote> <p>仅有四个圆？</p> </blockquote> <p>No，这些圆圈都是示意图。你也许会发现你需要多于这四个。没有规则说你必须总是有正好这四个圆。但是，<strong>依赖规则</strong>（<em>The Dependency Rule</em>）总是适用。代码中的依赖总是指向内部。随着你往内部的移动，抽象的层次就会增加。最外层的圆是低层次的具体细节。随着你往内部移动，软件变得更抽象，并且封装高阶的政策（<em>policies</em>）。最内层的圆是最具有普遍性。</p> <h2 id="crossing-boundaries">Crossing boundaries</h2> <blockquote> <p>跨越边界</p> </blockquote> <p>图中的右下方是一个我们如何跨越圆圈边界的示例。它显示了Controllers和Presenters与用例层在下一层的交互。注意控制流。它从controller开始，遍历用例层，并且之后在presenter执行结束。也注意代码中的依赖。它们每一个指向用例层的内部。</p> <p>通常我们使用<a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖反转原则</a>解决这一明显的矛盾。例如，在诸如Java的语言中，我们将安排接口和继承关系，以便源代码依赖关系在跨越边界的正确点减少控制流。</p> <p>例如，考虑到用例层需要调用presenter。但是，这个调用必须不能是直接调用，因为将会违反依赖原则：外圈的名字不能被内圈提及。所以我们在内圈中让用例调用一个接口（这里显示为用例输出端口<em>Use Case Output Port</em>），并让外圈中的presenter实现它。</p> <p>相同的技术被用于跨越所有架构中的边界上。我们采用了动态多态性的有点来创建代码依赖，减少控制流，无论控制流走向哪个方向，都以便于我们遵守依赖原则。</p> <h2 id="what-data-crosses-the-boundaries">What data crosses the boundaries</h2> <blockquote> <p>什么数据跨越边界</p> </blockquote> <p>通常来讲，跨越边界的数据仅仅是数据结构。你可以使用基本结构或简单的数据转换（<em>Data Transfer</em>）对象。或者，数据也可以仅仅是函数调用中的参数。或者你可以将它打包到HashMap中，或者构建它成为一个对象。重要的事情是隔离的、简单的数据结构被传进跨越边界。我们不希望作弊并传递Entity或数据库的某一行。我们也不希望数据结构有任何一个类型违反依赖原则。</p> <p>例如，许多数据库框架在查询响应中返回一个便捷的数据格式。我们也许称之为RowStructure。我们不希望传递行结构到内部跨越边界。这会违反依赖原则，因为它将强制一个内部圆去知道某些外部圆中的事物。</p> <p>所以，当我们传递数据跨越边界时，它总是采用最适合内圈的形式。</p> <h2 id="conclusion">Conclusion</h2> <blockquote> <p>总结</p> </blockquote> <p>遵守这些简单的规则并不难，并且将节省你大量的麻烦事。通过将软件分层，并且遵守依赖原则，你讲创建一个本质上可测试的系统，并具有所有暗含的好处。当系统中任何一个外部部分过时的时候，例如数据库或Web框架，你可以以最少的体力替换掉过时的元素。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[by Robert C. Martin (Uncle Bob) 13 August 2012 https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html]]></summary></entry><entry><title type="html">LaTeX Workshop 配置信息</title><link href="https://jkfx.github.io/blog/2022/Ubuntu-22.04-MacOS-Monterey-%E4%B8%BB%E9%A2%98/" rel="alternate" type="text/html" title="LaTeX Workshop 配置信息"/><published>2022-05-28T22:03:00+00:00</published><updated>2022-05-28T22:03:00+00:00</updated><id>https://jkfx.github.io/blog/2022/Ubuntu%2022.04%20MacOS%20Monterey%20%E4%B8%BB%E9%A2%98</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/Ubuntu-22.04-MacOS-Monterey-%E4%B8%BB%E9%A2%98/"><![CDATA[<p>首先更新源以及升级软件：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt upgrade
</code></pre></div></div> <blockquote> <p>也可以更新一下驱动：</p> <p><code class="language-plaintext highlighter-rouge">sudo ubuntu-drivers autoinstall</code></p> </blockquote> <hr/> <p>之后安装 <code class="language-plaintext highlighter-rouge">gnome-tweaks</code> 以及 <code class="language-plaintext highlighter-rouge">gnome-shell-extensions</code> ：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>gnome-tweaks gnome-shell-extensions
</code></pre></div></div> <p>到<em>GNOME Shell Extensions</em>网站安装谷歌浏览器扩展：<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a> 。</p> <p>接下来安装 <em>User Themes</em> 主题插件： <a href="https://extensions.gnome.org/extension/19/user-themes/">https://extensions.gnome.org/extension/19/user-themes/</a> 。</p> <hr/> <p>克隆 GitHub 上的 <em>WhiteSur-gtk-theme</em> 主题： <a href="https://github.com/vinceliuice/WhiteSur-gtk-theme">https://github.com/vinceliuice/WhiteSur-gtk-theme</a> 到任意你想存放的目录。</p> <p>进入到 <em>WhiteSur-gtk-theme</em> 目录下，找到 <code class="language-plaintext highlighter-rouge">install.sh</code> 以及 <code class="language-plaintext highlighter-rouge">tweaks.sh</code> 脚本文件，执行命令安装主题：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./install.sh <span class="nt">-t</span> all <span class="nt">-N</span> glassy <span class="nt">-s</span> 220
<span class="nb">sudo</span> ./tweaks.sh <span class="nt">-g</span> <span class="nt">-f</span> monterey
</code></pre></div></div> <p>下载并提取 <em>Mkos-Big-Sur</em> 图标包到你的 <strong>home</strong> 下的 <code class="language-plaintext highlighter-rouge">.icons</code> 目录： <a href="https://www.gnome-look.org/p/1400021">https://www.gnome-look.org/p/1400021</a> 。</p> <hr/> <p>找到 Ubuntu 应用程序 优化（<em>tweaks</em>），选择 <em>外观</em> 菜单，在 <em>图标</em> 、 <em>Shell</em> 以及 <em>过时应用程序</em> 中应用 <em>WhiteSur-</em> 主题以及 <em>Mkos-Big-Sur</em> 图标包。</p> <p>在 <em>窗口标题栏</em> 菜单中将 <em>标题栏按钮</em> 放置到 <em>左</em> 侧。</p> <p>在 <em>GNOME Shell Extensions</em> 网站安装 <em>Blur my Shell</em> 插件： <a href="https://extensions.gnome.org/extension/3193/blur-my-shell/">https://extensions.gnome.org/extension/3193/blur-my-shell/</a> 。</p> <p>在 <em>GNOME Shell Extensions</em> 网站安装 <em>Compiz alike magic lamp effect</em> 插件： <a href="https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/">https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/</a> 。</p> <p>在终端中执行命令：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gsettings <span class="nb">set </span>org.gnome.shell.extensions.dash-to-dock click-action <span class="s1">'minimize'</span>
</code></pre></div></div> <p>找到 Ubuntu 应用程序的 扩展（<em>extensions</em>），找到 <em>Blur my Shell</em> 扩展，点击 <em>设置</em> 按钮，在 <em>Dash</em> 窗口中将 <em>Dash to Dock blur</em> 选项取消勾选。</p> <p>最后，选择一张你喜欢的 MacOS 壁纸，也可以到这个 GitHub 仓库下载： <a href="https://github.com/vinceliuice/WhiteSur-wallpapers">https://github.com/vinceliuice/WhiteSur-wallpapers</a> 。</p> <ul> <li>参考链接： <a href="https://youtu.be/Y6k7THQ3x6U">https://youtu.be/Y6k7THQ3x6U</a></li> </ul> <hr/> <p>常用 Gnome Shell Extensions</p> <ul> <li><a href="https://extensions.gnome.org/extension/1460/vitals/">Vitals</a></li> <li><a href="https://extensions.gnome.org/extension/675/lunar-calendar/">Lunar Calendar 农历</a></li> <li><a href="https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/">Bluetooth Quick Connect</a></li> <li><a href="https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/">Compiz alike magic lamp effect</a></li> <li><a href="https://extensions.gnome.org/extension/3438/jiggle/">Jiggle</a></li> </ul>]]></content><author><name></name></author><summary type="html"><![CDATA[首先更新源以及升级软件：]]></summary></entry><entry><title type="html">CASIA-WebMaskedFace 模拟佩戴口罩人脸数据集</title><link href="https://jkfx.github.io/blog/2022/CASIA-WebMaskedFace-%E6%A8%A1%E6%8B%9F%E4%BD%A9%E6%88%B4%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E6%95%B0%E6%8D%AE%E9%9B%86/" rel="alternate" type="text/html" title="CASIA-WebMaskedFace 模拟佩戴口罩人脸数据集"/><published>2022-04-14T10:55:00+00:00</published><updated>2022-04-14T10:55:00+00:00</updated><id>https://jkfx.github.io/blog/2022/CASIA-WebMaskedFace%20%E6%A8%A1%E6%8B%9F%E4%BD%A9%E6%88%B4%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E6%95%B0%E6%8D%AE%E9%9B%86</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/CASIA-WebMaskedFace-%E6%A8%A1%E6%8B%9F%E4%BD%A9%E6%88%B4%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E6%95%B0%E6%8D%AE%E9%9B%86/"><![CDATA[<p>Based on CASIA-WebFace Dataset using MaskTheFace tool mask the face images of datasets.</p> <p>基于CASIA-WebFace数据集，使用MaskTheFace工具给数据集中的人脸图像“戴上口罩”。</p> <h2 id="数据集介绍">数据集介绍</h2> <p>此数据集是在源数据集 <a href="https://arxiv.org/pdf/1411.7923v1.pdf">CASIA-Webface</a> 之上，使用 <a href="https://arxiv.org/abs/2008.11104">MaskTheFace</a> 工具对 CASIA-Webface 数据集中的图像进行佩戴口罩，此数据所涉及到的口罩类型有：Surgical（白色医用外科口罩）、Surgical Blue（蓝色医用外科口罩）、N95、KN95以及Cloth（黑色布质口罩）。口罩的分布类型都是均匀分布随机生成的。</p> <p><img src="https://tvax4.sinaimg.cn/large/006VTcCxly1h191411yh2j313w0aujyr.jpg" alt="image"/></p> <p>关于口罩类型以及口罩颜色和材质的类型的更多介绍，可以查看 <a href="https://github.com/aqeelanwar/MaskTheFace">原工具仓库</a> 。</p> <p>CASIA-WebMaskedFace 有 10,575 个实体人物， 494,414 张人脸图像。</p> <blockquote> <p>此数据集是在 CASIA-Webface 数据集原封不动的基础上进行配到口罩的模拟，所以与原数据集有相同的实体和图像数量。</p> </blockquote> <p>武汉大学国家多媒体软件工程技术研究中心在最早做了相关的 <a href="https://arxiv.org/abs/2003.09093">研究</a> ，也提出了当时最大的模拟口罩人脸数据集和一个真实世界的人脸佩戴口罩的数据集。</p> <p><a href="https://arxiv.org/abs/2008.11104">Aqeel Anwar, Arijit Raychowdhury</a> 在之后也提出了一个真实世界佩戴口罩的人脸数据集，并且提出了一个工具，也就是上文提到的 <a href="https://github.com/aqeelanwar/MaskTheFace">MaskTheFace</a> 用来在已有的人脸数据集上进行模拟佩戴口罩。</p> <h3 id="数据示例">数据示例</h3> <p><img src="https://tvax1.sinaimg.cn/large/006VTcCxly1h191m9mhfyj30pf0atwme.jpg" alt="image"/></p> <p><img src="https://tvax4.sinaimg.cn/large/006VTcCxly1h191pig6fmj30pm0al7be.jpg" alt="image"/></p> <p><img src="https://tvax2.sinaimg.cn/large/006VTcCxly1h191ojwfj1j30pd0aswmv.jpg" alt="image"/></p> <p><img src="https://tvax1.sinaimg.cn/large/006VTcCxly1h191qg3bm0j30pe0amwn6.jpg" alt="image"/></p> <h2 id="下载地址">下载地址</h2> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Kaggle：<a href="https://www.kaggle.com/datasets/geekfx/casia-webmaskedface">https://www.kaggle.com/datasets/geekfx/casia-webmaskedface</a></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Kaggle (cropped using MTCNN, 160x160)：<a href="https://www.kaggle.com/datasets/geekfx/casia-webmaskedface-cropped">https://www.kaggle.com/datasets/geekfx/casia-webmaskedface-cropped</a></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>百度网盘</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Google Drive</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>GitHub</li> </ul>]]></content><author><name></name></author><summary type="html"><![CDATA[Based on CASIA-WebFace Dataset using MaskTheFace tool mask the face images of datasets.]]></summary></entry><entry><title type="html">LaTeX Workshop 配置信息</title><link href="https://jkfx.github.io/blog/2022/LaTeX-Workshop-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/" rel="alternate" type="text/html" title="LaTeX Workshop 配置信息"/><published>2022-02-25T12:33:00+00:00</published><updated>2022-02-25T12:33:00+00:00</updated><id>https://jkfx.github.io/blog/2022/LaTeX%20Workshop%20%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/LaTeX-Workshop-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"><![CDATA[<p>使用 VS Code 编写 LaTeX 论文时，安装 LaTeX Workshop 插件可以实现非常多的功能，但是由于 LaTeX Workshop 默认配置的编译命令是 <code class="language-plaintext highlighter-rouge">latexmk</code> ，而在编写中文论文时通常需要使用 <code class="language-plaintext highlighter-rouge">xelatex</code> 命令来编译文件源代码，所以为了正常使用 LaTeX Workshop 编写中文论文，通常需要对 LaTeX Workshop 进行自定义修改。</p> <p>以下是笔者根据官方文档自己修改的设置选项信息，每一项的设置上面都写好了中文注释，也为了日后笔者更方便的进行配置、修改。</p> <blockquote> <p>关于 LaTeX Workshop 的配置官方文档信息，可以参考 <a href="https://github.com/James-Yu/LaTeX-Workshop/wiki">LaTeX Workshop GitHub Wiki</a></p> </blockquote> <p>本文给出 3 种编译方式：</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">xelatex</code> 命令编译两次</li> </ul> <blockquote> <p>通常生成目录时，通常先编译一次生成目录所需的辅助文件，例如目录项等，然后编译第二遍结合辅助文件生成最终的 PDF</p> </blockquote> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">BibTeX</code> 参考文献工具时所需用到的编译命令</li> <li>使用 <code class="language-plaintext highlighter-rouge">BibLaTeX</code> 参考文献所需用到的编译命令</li> </ul> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ******** LaTeX Workshop 配置信息 ********</span>
<span class="c1">// 文件修改时不自动编译</span>
<span class="c1">// "never", "onSave", "onFileChange"</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.autoBuild.run</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">never</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// LaTeX Workshop 编译源代码文件的快捷键默认为：ctrl + alt + b</span>
<span class="c1">// 但是在有些情况下，ctrl + alt 快捷键被占用</span>
<span class="c1">// 将下面设置项改为 true 可以启动替代的快捷键</span>
<span class="c1">// ctrl + l / alt + letter</span>
<span class="dl">"</span><span class="s2">latex-workshop.bind.altKeymap.enabled</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="c1">// 编译文件时选用哪种 recipes 方案</span>
<span class="c1">// recipes 的定义在下文</span>
<span class="c1">// "first" （默认）为定义在下文 recipes 中的第一项</span>
<span class="c1">// "lastUsed" 为上次使用运行的 recipe</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.recipe.default</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">lastUsed</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// 预览生产的 pdf 文件方式：在 vscode 窗口中预览</span>
<span class="dl">"</span><span class="s2">latex-workshop.view.pdf.viewer</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">tab</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// 设置在使用 LaTeX Workshop 编译后，自动清理辅助文件</span>
<span class="c1">// 也可以设置为 "never" 表示不自动清理辅助文件</span>
<span class="c1">// 设置 "onFailed" 为当编译失败时自动清理辅助文件</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.autoClean.run</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">onBuilt</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// 编译 LaTeX 时使用的工具（tool）顺序</span>
<span class="c1">// 工具（tool）需要自定义</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.recipes</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
    <span class="c1">// 没有参考文献的编译方式</span>
    <span class="c1">// 为了正确生成目录项，一般需要编译两次源代码</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="c1">// 使用 BibTeX 参考文献工具的编译方式</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex ➞ bibtex ➞ xelatex × 2</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">bibtex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="c1">// 使用 BibLaTeX 参考文献工具的编译方式</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex ➞ biber ➞ xelatex × 2</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">biber</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">],</span>
<span class="c1">// 定义 recipes 中工具的命令以及参数</span>
<span class="c1">// 以下列出 LaTeX Workshop 定义好的占位符</span>
<span class="c1">// %DOC%             The root file full path without the extension</span>
<span class="c1">// %DOC_W32%         The root file full path without the extension with \ path separator on Windows</span>
<span class="c1">// %DOCFILE%         The root file name without the extension</span>
<span class="c1">// %DOC_EXT%         The root file full path with the extension</span>
<span class="c1">// %DOC_EXT_W32%     The root file full path with the extension with \ path separator on Windows</span>
<span class="c1">// %DOCFILE_EXT%     The root file name with the extension</span>
<span class="c1">// %DIR%             The root file directory</span>
<span class="c1">// %DIR_W32%         The root file directory with \ path separator on Windows</span>
<span class="c1">// %TMPDIR%             A temporary folder for storing ancillary files</span>
<span class="c1">// %OUTDIR%             The output directory configured in latex-workshop.latex.outDir</span>
<span class="c1">// %OUTDIR_W32%         The output directory configured in latex-workshop.latex.outDir with \ path separator on Windows</span>
<span class="c1">// %WORKSPACE_FOLDER% The current workspace path</span>
<span class="c1">// %RELATIVE_DIR%     The root file directory relative to the workspace folder</span>
<span class="c1">// %RELATIVE_DOC%     file root file path relative to the workspace folder</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">command</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">args</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">-synctex=1</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">-interaction=nonstopmode</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">-file-line-error</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">%DOC%</span><span class="dl">"</span>
        <span class="p">],</span>
        <span class="dl">"</span><span class="s2">env</span><span class="dl">"</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bibtex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">command</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bibtex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">args</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">%DOCFILE%</span><span class="dl">"</span>
        <span class="p">],</span>
        <span class="dl">"</span><span class="s2">env</span><span class="dl">"</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">biber</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">command</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">biber</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">args</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">%DOCFILE%</span><span class="dl">"</span>
        <span class="p">],</span>
        <span class="dl">"</span><span class="s2">env</span><span class="dl">"</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">],</span>
</code></pre></div></div> <p>使用以上配置选项将上述代码拷贝到你的 VS Code 的 <code class="language-plaintext highlighter-rouge">json</code> 设置文件下即可。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[使用 VS Code 编写 LaTeX 论文时，安装 LaTeX Workshop 插件可以实现非常多的功能，但是由于 LaTeX Workshop 默认配置的编译命令是 latexmk ，而在编写中文论文时通常需要使用 xelatex 命令来编译文件源代码，所以为了正常使用 LaTeX Workshop 编写中文论文，通常需要对 LaTeX Workshop 进行自定义修改。]]></summary></entry><entry><title type="html">关于Linux下LaTeX无法找到已安装字体的问题与解决</title><link href="https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8ELinux%E4%B8%8BLaTeX%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%B7%B2%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/" rel="alternate" type="text/html" title="关于Linux下LaTeX无法找到已安装字体的问题与解决"/><published>2021-08-12T22:47:00+00:00</published><updated>2021-08-12T22:47:00+00:00</updated><id>https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8ELinux%E4%B8%8BLaTeX%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%B7%B2%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3</id><content type="html" xml:base="https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8ELinux%E4%B8%8BLaTeX%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%B7%B2%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"><![CDATA[<p>当我在Ubuntu系统下使用Latex时，在编译渲染时报出了<code class="language-plaintext highlighter-rouge">Font "xxx" does not contain requested</code>这种错误，其中<code class="language-plaintext highlighter-rouge">xxx</code>就是你可能想使用的字体格式。</p> <p>然而我的Ubuntu系统已经正确安装了一些常用中文字体，然而在LaTeX编译渲染时还会报出错误。</p> <p>由于笔者为了解决这个问题翻遍了国内外的网站、去查看了Texlive官方文档，耗费了许多时间与精力，都没能找到解决我的问题的信息，人们的时间往往都很珍贵，一般找不到解决方案过后，往往都不了了之，本着互联网极客精神（<strong>开源精神</strong>），在这里将笔者的解决过程记录并分享，希望人们可以将这种精神继承并传承下去。</p> <blockquote> <p>我甚至在Texlive的官方安装文档中看到这么一段话：</p> <p><img src="https://tva2.sinaimg.cn/large/006VTcCxly1gtee10q7x6j31f10cbqgx.jpg" alt="image"/></p> <p>可以看到关乎于LaTeX排版中让人非常头疼的问题就是汉字的一些处理了，好在今天有非常多好用的宏包可以解决处理这个问题。</p> </blockquote> <p>首先看一下笔者出现的问题：</p> <p><img src="https://tva3.sinaimg.cn/large/006VTcCxly1gtedg611ydj60w00a9q7w02.jpg" alt="image"/></p> <p><img src="https://tva4.sinaimg.cn/large/006VTcCxly1gtediiunx3j618z07d79402.jpg" alt="image"/></p> <p>可以看到终端给出的错误提示是未能找到已安装的字体（<em>installed font not found</em>），有了这句话的提示，笔者想的可能是，在我的系统上已安装了的字体中，在LaTeX中未能正确地引用，查看代码中可以看到：</p> <p><img src="https://tvax4.sinaimg.cn/large/006VTcCxly1gtedm8youxj30mt061jvl.jpg" alt="image"/></p> <p>在这里设置字体格式的时候我们设置楷体对应的字体文件为<code class="language-plaintext highlighter-rouge">simkai</code>，我们可以查看我们的字体库中是否有<code class="language-plaintext highlighter-rouge">simkai.ttf</code>楷体的字体文件：</p> <p>在Ubuntu存放字体的目录<code class="language-plaintext highlighter-rouge">/usr/share/fonts/</code>下可以使用<code class="language-plaintext highlighter-rouge">find</code>命令查找：</p> <p><img src="https://tva1.sinaimg.cn/large/006VTcCxly1gtedq0ili0j61570aigqc02.jpg" alt="image"/></p> <p>可以看到，笔者的系统中已经存放了<code class="language-plaintext highlighter-rouge">simkai.ttf</code>这个字体文件，为什么LaTeX还没有找到这个字体呢。</p> <p>通过一番排查，原来是在Ubuntu中，对字体的使用并不仅仅是字体文件名，而是另一个别名。</p> <p>我们可以使用<code class="language-plaintext highlighter-rouge">fc-list</code>来查看系统可用的字体列表，然后使用<code class="language-plaintext highlighter-rouge">grep</code>匹配<code class="language-plaintext highlighter-rouge">simkai.ttf</code>的字体文件，可以进一步查看字体的信息：</p> <p><img src="https://tva1.sinaimg.cn/large/006VTcCxly1gtedsq4tgrj61580r9b2902.jpg" alt="image"/></p> <p>原来，图中1号框中的名字只是字体文件名，而在系统应用中想要使用这个字体，我们需要指定2号框中的字体名，例如本图，我们想要使用楷体就需要指定<code class="language-plaintext highlighter-rouge">KaiTi</code>或<code class="language-plaintext highlighter-rouge">楷体</code>这个名字。</p> <p>回到LaTeX代码中，将之前出现错误原因的<code class="language-plaintext highlighter-rouge">simkai</code>替换成<code class="language-plaintext highlighter-rouge">KaiTi</code>即可解决问题。</p> <p><img src="https://tva4.sinaimg.cn/large/006VTcCxly1gtedwcpyd0j60no06dtd402.jpg" alt="image"/></p> <p><img src="https://tvax3.sinaimg.cn/large/006VTcCxly1gteduycwvij60i102swf302.jpg" alt="image"/></p> <p>为了进一步验证笔者的猜想，可以看到上图代码中，在<code class="language-plaintext highlighter-rouge">KaiTi</code>的下面还使用了<code class="language-plaintext highlighter-rouge">SimSun</code>宋体的使用，然而<code class="language-plaintext highlighter-rouge">SimSun</code>并不报错，这里笔者想可以继续查看<code class="language-plaintext highlighter-rouge">SimSun</code>的字体信息，其后面的别名应该包含<code class="language-plaintext highlighter-rouge">SimSun</code>。</p> <p><img src="https://tva2.sinaimg.cn/large/006VTcCxly1gtedz60mqcj61540r77wh02.jpg" alt="image"/></p> <p>所以笔者的猜想是正确的，所以在我们不同的系统、不同的字体文件中，每个人发生无法正确找到我们想要使用的字体的错误可能都不一样，因为我们使用的字体文件不同可能导致我们的在应用中使用字体中需要引用的名称的不同而不同，所以出现这种问题我们要具体问题具体分析，对症下药。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[当我在Ubuntu系统下使用Latex时，在编译渲染时报出了Font "xxx" does not contain requested这种错误，其中xxx就是你可能想使用的字体格式。]]></summary></entry><entry><title type="html">Ubuntu 21.04 使用命令行分配静态IP地址</title><link href="https://jkfx.github.io/blog/2021/Ubuntu-21.04-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E9%85%8D%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/" rel="alternate" type="text/html" title="Ubuntu 21.04 使用命令行分配静态IP地址"/><published>2021-08-03T15:43:00+00:00</published><updated>2021-08-03T15:43:00+00:00</updated><id>https://jkfx.github.io/blog/2021/Ubuntu%2021.04%20%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E9%85%8D%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80</id><content type="html" xml:base="https://jkfx.github.io/blog/2021/Ubuntu-21.04-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E9%85%8D%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/"><![CDATA[<h2 id="查看网卡-logical-name">查看网卡 logical name</h2> <p>输入 <code class="language-plaintext highlighter-rouge">sudo lshw -class network</code> 后回车，在列出的信息中找到 <code class="language-plaintext highlighter-rouge">local name</code> 键，查看其后面的值是多少。</p> <p><img src="//tva3.sinaimg.cn/large/006VTcCxly1gt3mt42tx4j315w0tsb1j.jpg" alt="image"/></p> <h2 id="编辑配置文件">编辑配置文件</h2> <p>以本文的 <code class="language-plaintext highlighter-rouge">ens32</code> 为例，下面我们进入到 <code class="language-plaintext highlighter-rouge">/etc/netplan</code> 目录下，使用 <code class="language-plaintext highlighter-rouge">cd /etc/netplan</code> 命令。</p> <p>然后使用 <code class="language-plaintext highlighter-rouge">sudo vim 99_config.yaml</code> 创建一个名为 <code class="language-plaintext highlighter-rouge">99_config.yaml</code> 的配置文件，并且在配置文件中编辑输入我们需要的网络地址信息。</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">network</span><span class="pi">:</span>
  <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">renderer</span><span class="pi">:</span> <span class="s">networkd</span>
  <span class="na">ethernets</span><span class="pi">:</span>
    <span class="na">ens32</span><span class="pi">:</span>
      <span class="na">addresses</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">192.168.187.101/24</span>
      <span class="na">gateway4</span><span class="pi">:</span> <span class="s">192.168.187.2</span>
      <span class="na">nameservers</span><span class="pi">:</span>
          <span class="na">search</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">mydomain</span><span class="pi">,</span> <span class="nv">otherdomain</span><span class="pi">]</span>
          <span class="na">addresses</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">114.114.114.114</span><span class="pi">,</span> <span class="nv">8.8.8.8</span><span class="pi">]</span>
</code></pre></div></div> <p><img src="//tvax3.sinaimg.cn/large/006VTcCxly1gt3n4s2pmaj317d0tuk3t.jpg" alt="image"/></p> <p>如图所示，讲配置文件中的键值对配置成我们需要的网络信息后，输入 <code class="language-plaintext highlighter-rouge">:wq</code> 保存并且退出。</p> <h2 id="刷新生效配置文件">刷新生效配置文件</h2> <p>然后我们输入 <code class="language-plaintext highlighter-rouge">sudo netplan apply</code> 将配置文件生效即可。</p> <p>可以输入 <code class="language-plaintext highlighter-rouge">ip a</code> 查看网络信息是否生效。</p> <p><img src="//tvax3.sinaimg.cn/large/006VTcCxly1gt3n6scooij31990t01kx.jpg" alt="image"/></p> <p>可以看到图中的IP地址已经变成了我们所需要的地址。</p> <h2 id="参考文档">参考文档</h2> <p><a href="https://ubuntu.com/server/docs/network-configuration">Network Configuration</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[查看网卡 logical name]]></summary></entry><entry><title type="html">批量下载YouTube播放列表（playlist）视频、字幕</title><link href="https://jkfx.github.io/blog/2021/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDYouTube%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8-playlist-%E8%A7%86%E9%A2%91-%E5%AD%97%E5%B9%95/" rel="alternate" type="text/html" title="批量下载YouTube播放列表（playlist）视频、字幕"/><published>2021-07-21T15:30:00+00:00</published><updated>2021-07-21T15:30:00+00:00</updated><id>https://jkfx.github.io/blog/2021/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDYouTube%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8%EF%BC%88playlist%EF%BC%89%E8%A7%86%E9%A2%91%E3%80%81%E5%AD%97%E5%B9%95</id><content type="html" xml:base="https://jkfx.github.io/blog/2021/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDYouTube%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8-playlist-%E8%A7%86%E9%A2%91-%E5%AD%97%E5%B9%95/"><![CDATA[<h2 id="所需工具">所需工具</h2> <ul> <li><a href="https://www.python.org/downloads/">python</a></li> <li><a href="https://github.com/ytdl-org/youtube-dl/releases">youtube-dl</a></li> <li><a href="http://ffmpeg.org/download.html">FFmpeg</a></li> <li><em>Scientific上网</em></li> </ul> <p>其实可以直接使用<em>youtube-dl</em>执行文件直接下载，若我们需要对多个<em>YouTube</em>播放列表进行批量下载，便可利用<em>python</em>进行批处理，其中本文实现的功能就是对多个<em>YouTube</em>播放列表都创建一个对应的同名文件夹，然后将视频、字幕文件全部下载到一起。</p> <p>其中<em>FFmpeg</em>是<em>youtube-dl</em>用来合并视音频文件用的，虽然<em>YouTube</em>上视频的格式有<em>MP4</em>的格式，不需要对视频、音频文件进行合并，如果你需要下载<em>2K</em>、<em>4K</em>的高清晰度的视频文件，一般都是采用<em><a href="https://baike.baidu.com/item/WebM/2455966?fr=aladdin">webm</a></em>的格式将视频、音频文件分开。尽管如此，<em>youtube-dl</em>也已经为我们造好了轮子，合并视音频文件的步骤无需我们干扰，只需要将其所用的工具添加到系统的<strong>环境变量</strong>。</p> <p><strong>再次说明</strong>，你需要将下载下来的<em>youtube-dl</em>的可执行文件，以及<em>FFmpeg</em>的<strong><em>bin</em></strong>目录都添加到系统的<strong>环境变量</strong>中。</p> <h2 id="实现代码">实现代码</h2> <p>首先创建python的字典，其中<em>key</em>是播放列表的名称，也是将要创建文件夹的名称，<em>value</em>是播放列表（playlist）对应的YouTube链接。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">key(播放列表的名称，也即创建文件夹的名称)</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">YouTube播放列表链接</span><span class="sh">"</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里以麻省理工公开课<a href="http://introtodeeplearning.com/">MIT 6.S191</a>为例，打开对应课程的YouTube播放列表。</p> <p><img src="//tva1.sinaimg.cn/large/006VTcCxgy1gsokx7w77oj31z2164e81.jpg" alt="image"/></p> <p>将对应播放列表的名称和链接放入python字典中。</p> <p>然后直接遍历此字典的<em>key</em>和<em>value</em>使用<em>os</em>库的<em>system</em>方法调用<em>youtube-dl</em>命令对视音频进行下载。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">for </span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">m</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="c1"># 创建同名文件夹
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># 进入到刚刚创建的文件夹中
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># 调用 youtube-dl 命令对视频链接进行下载
</span>    <span class="c1"># 本条命令下载的字幕是英文
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-sub --sub-lang en -f </span><span class="sh">"</span><span class="s">bestvideo+bestaudio</span><span class="sh">"</span><span class="s"> -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># 如果需要下载自动翻译的中文字幕，便需要执行下一行
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-auto-sub --sub-lang zh-Hans --skip-download -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># 返回到上一级目录
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="sh">"</span><span class="s">../</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <blockquote> <p>即使<em><a href="https://github.com/ytdl-org/youtube-dl/blob/master/README.md">youtube-dl</a></em>的<em>GitHub</em>上已经有非常详细的命令参数的说明，这里还是简单地说明一下。</p> <p>语法格式大体为：youtube-dl [OPTIONS] URL [URL…]</p> <p>本文所用到的选项有：</p> <ul> <li><em>–write-sub</em> 下载视频对应的字幕文件</li> <li><em>–sub-lang</em> 指定下载字幕文件的语言 <ul> <li><em>en</em> 英语</li> <li><em>zh-Hans</em> 中文简体</li> </ul> </li> <li><em>–write-auto-sub</em> 当原视频文件没有带中文简体的字幕时，需要使用本参数下载<em>自动翻译</em>的字幕文件</li> <li><em>-f</em> 指定视频格式 <ul> <li>这里的<em>bestvideo+bestaudio</em>的意思是下载视频清晰度最好的视频文件和音频质量最好的音频文件并且将它们合并</li> </ul> </li> <li><em>-o</em> 指定下载的文件的名称 <ul> <li><em>%(title)s</em> 表明视频文件的标题名</li> <li><em>%(ext)s</em> 下载文件的扩展格式</li> <li><em>%(autonumber)s</em> 如果你想要对每个下载文件名称前面加上一个序号，便使用这个参数</li> </ul> </li> <li><em>–skip-download</em> 跳过视频文件仅下载字幕文件</li> </ul> </blockquote> <h2 id="完整代码">完整代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">MIT 6.046J Design and Analysis of Algorithms, Spring 2015</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 6.042J Mathematics for Computer Science, Fall 2010</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PLB7540DEDD482705B</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 18.065 Matrix Methods in Data Analysis, Signal Processing, and Machine Learning, Spring 2018</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PLUl4u3cNGP63oMNUHXqIUcrkS2PivhN3k</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 18.02 Multivariable Calculus, Fall 2007</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PL4C4C8A7D06566F38</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 18.01 Single Variable Calculus, Fall 2006</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PL590CCC2BC5AF3BC1</span><span class="sh">"</span>
<span class="p">}</span>

<span class="nf">for </span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">m</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-sub --sub-lang en -f </span><span class="sh">"</span><span class="s">bestvideo+bestaudio</span><span class="sh">"</span><span class="s"> -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-auto-sub --sub-lang zh-Hans --skip-download -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="sh">"</span><span class="s">../</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>将代码中字典变量的<em>key</em>和<em>value</em>替换成你需要的下载链接，将其保存到<code class="language-plaintext highlighter-rouge">.py</code>文件格式后，执行<code class="language-plaintext highlighter-rouge">python 文件名.py</code>便可进行下载。</p> <h2 id="效果展示">效果展示</h2> <p>如果你的梯子网速给力的话，下载速度还是非常可观的。</p> <p><img src="//tvax2.sinaimg.cn/large/006VTcCxgy1gsolqbnjbzj31ta0zhgwg.jpg" alt="image"/></p> <p><img src="//tva3.sinaimg.cn/large/006VTcCxgy1gsolomow99j31z4168kjl.jpg" alt="image"/></p>]]></content><author><name></name></author><summary type="html"><![CDATA[所需工具]]></summary></entry><entry><title type="html">关于 RNN 循环神经网络的反向传播求导</title><link href="https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8E-RNN-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC/" rel="alternate" type="text/html" title="关于 RNN 循环神经网络的反向传播求导"/><published>2021-01-11T20:19:00+00:00</published><updated>2021-01-11T20:19:00+00:00</updated><id>https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8E%20RNN%20%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC</id><content type="html" xml:base="https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8E-RNN-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC/"><![CDATA[ <p>本文是对 RNN 循环神经网络中的每一个神经元进行反向传播求导的数学推导过程，下面还使用 <code class="language-plaintext highlighter-rouge">PyTorch</code> 对导数公式进行编程求证。</p> <h2 id="rnn-神经网络架构">RNN 神经网络架构</h2> <p>一个普通的 RNN 神经网络如下图所示：</p> <p><img src="https://tvax1.sinaimg.cn/large/006VTcCxly1gmfae8mswmj317a0e00u2.jpg" alt="图片1"/></p> <p>其中 \(x^{\langle t \rangle}\) 表示某一个输入数据在 \(t\) 时刻的输入；\(a^{\langle t \rangle}\) 表示神经网络在 \(t\) 时刻时的<em>hidden state</em>，也就是要传送到 \(t+1\) 时刻的值；\(y^{\langle t \rangle}\) 则表示在第 \(t\) 时刻输入数据传入以后产生的预测值，在进行预测或 <em>sampling</em> 时 \(y^{\langle t \rangle}\) 通常作为下一时刻即 \(t+1\) 时刻的输入，也就是说 \(x^{\langle t \rangle}=\hat{y}^{\langle t \rangle}\) ；下面对数据的维度进行说明。</p> <ul> <li>输入： \(x\in\mathbb{R}^{n_x\times m\times T_x}\) 其中 \(n_x\) 表示每一个时刻输入向量的长度；\(m\) 表示数据批量数（<em>batch</em>）；\(T_x\) 表示共有多少个输入的时刻（<em>time step</em>）。</li> <li>hidden state：\(a\in\mathbb{R}^{n_a\times m\times T_x}\) 其中 \(n_a\) 表示每一个 <em>hidden state</em> 的长度。</li> <li>预测：\(y\in\mathbb{R}^{n_y\times m\times T_y}\) 其中 \(n_y\) 表示预测输出的长度；\(T_y\) 表示共有多少个输出的时刻（<em>time step</em>）。</li> </ul> <h2 id="rnn-神经元">RNN 神经元</h2> <p>下图所示的是一个特定的 RNN 神经元：</p> <p><img src="https://tvax2.sinaimg.cn/large/006VTcCxly1gmfaesc2joj30z20didhj.jpg" alt="图片2"/></p> <p>上图说明了在第 \(t\) 时刻的神经元中，数据的输入 \(x^{\langle t \rangle}\) 和上一层的 <em>hidden state</em> \(a^{\langle t \rangle}\) 是如何经过计算得到下一层的 <em>hidden state</em> 和预测输出 \(\hat{y}^{\langle t \rangle}\) 。</p> <p>下面是对五个参数的维度说明：</p> <ul> <li> \[W_{aa}\in\mathbb{R}^{n_a\times n_a}\] </li> <li> \[W_{ax}\in\mathbb{R}^{n_a\times n_x}\] </li> <li> \[b_a\in\mathbb{R}^{n_a\times 1}\] </li> <li> \[W_{ya}\in\mathbb{R}^{n_y\times n_a}\] </li> <li> \[b_y\in\mathbb{R}^{n_y\times 1}\] </li> </ul> <p>计算 \(t\) 时刻的 <em>hidden state</em> \(a^{\langle t \rangle}\) ：</p> \[\begin{split} z1^{\langle t \rangle} &amp;= W_{aa} a^{\langle t-1 \rangle} + W_{ax} x^{\langle t \rangle} + b_a\\ a^{\langle t \rangle} &amp;= \tanh(z1^{\langle t \rangle}) \end{split}\] <p>预测 \(t\) 时刻的输出 \(\hat{y}^{\langle t \rangle}\) ：</p> \[\begin{split} z2^{\langle t \rangle} &amp;= W_{ya} a^{\langle t \rangle} + b_y\\ \hat{y}^{\langle t \rangle} &amp;= softmax(z2^{\langle t \rangle}) = \frac{e^{z2^{\langle t \rangle}}}{\sum_{i=1}^{n_y}e^{z2_i^{\langle t \rangle}}} \end{split}\] <h2 id="rnn-循环神经网络反向传播">RNN 循环神经网络反向传播</h2> <p>在当今流行的深度学习编程框架中，我们只需要编写一个神经网络的结构和负责神经网络的前向传播，至于反向传播的求导和参数更新，完全由框架搞定；即便如此，我们在学习阶段也要自己动手证明一下反向传播的有效性。</p> <h3 id="rnn-神经元的反向传播">RNN 神经元的反向传播</h3> <p>下图是 RNN 神经网络中的一个基本的神经元，图中标注了反向传播所需传来的参数和输出等。</p> <p><img src="https://tva4.sinaimg.cn/large/006VTcCxly1gmfagctqx4j30qu0e9t96.jpg" alt="图片3"/></p> <p>就如一个全连接的神经网络一样，损失函数 \(J\) 的导数通过微积分的链式法则（<em>chain rule</em>）反向传播到每一个时间轴上。</p> <p>为了方便，我们将损失函数关于神经元中参数的偏导符号简记为 \(\mathrm{d}\mathit{parameters}\) ；例如将 \(\frac{\partial J}{\partial W_{ax}}\) 记为 \(\mathrm{d}W_{ax}\) 。</p> <p><img src="https://tva4.sinaimg.cn/large/006VTcCxly1gmfagmbbw5j30zk0k0ta2.jpg" alt="图片4"/></p> <p>上图的反向传播的实现并没有包括全连接层和 <em>Softmax</em> 层。</p> <h3 id="反向传播求导">反向传播求导</h3> <p>计算损失函数关于各个参数的偏导数之前，我们先引入一个计算图（<em>computation graph</em>），其演示了一个 RNN 神经元的前向传播和如何利用计算图进行链式法则的反向求导。</p> <p><img src="https://tva1.sinaimg.cn/large/006VTcCxly1gmiwwe017fj31ia0j1go0.jpg" alt="image"/></p> <p>因为当进行反向传播求导时，我们需要将整个时间轴的输入全部输入之后，才可以从最后一个时刻开始往前传进行反向传播，所以我们假设 \(t\) 时刻就为最后一个时刻 \(T_x\) 。</p> <p>如果我们想要先计算 \(\frac{\partial\ell}{\partial W_{ax}}\) 所以我们可以从计算图中看到，反向传播的路径：</p> <p><img src="https://tva1.sinaimg.cn/large/006VTcCxly1gmiwutfx3gj31ig0j1mzn.jpg" alt="image"/></p> <p>我们需要按部就班的分别对从 \(W_{ax}\) 计算到 \(\ell\) 一路相关的变量进行求偏导，利用链式法则，将红色路线上一路的偏导数相乘到一起，就可以求出偏导数 \(\frac{\partial\ell}{\partial W_{ax}}\) ；所以我们得到：</p> \[\begin{split} \frac{\partial\ell}{\partial W_{ax}} &amp;= \frac{\partial\ell}{\partial\ell^{\langle t\rangle}} {\color{Red}{ \frac{\partial\ell^{\langle t\rangle}}{\partial\hat{y}^{\langle t\rangle}} \frac{\partial\hat{y}^{\langle t\rangle}}{\partial z2^{\langle t\rangle}} }} \frac{\partial z2^{\langle t\rangle}}{\partial a^{\langle t\rangle}} \frac{\partial a^{\langle t\rangle}}{\partial z1^{\langle t\rangle}} \frac{\partial z1^{\langle t\rangle}}{\partial W_{ax}} \end{split}\] <p>在上面的公式中，我们仅需要分别求出每一个偏导即可，其中红色的部分就是关于 \(\mathrm{Softmax}\) 的求导，关于 \(\mathrm{Softmax}\) 求导的推导过程，可以看本人的另一篇博客： <a href="/blog/2020/%E5%85%B3%E4%BA%8E-Softmax-%E5%9B%9E%E5%BD%92%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B1%82%E5%AF%BC%E6%95%B0%E8%BF%87%E7%A8%8B/">关于 Softmax 回归的反向传播求导数过程</a></p> <p>关于 \(\mathrm{tanh}\) 的求导公式如下：</p> \[\frac{\partial \tanh(x)} {\partial x} = 1 - \tanh^2(x)\] <p>所以上面的式子就得到：</p> \[\begin{split} \frac{\partial\ell}{\partial W_{ax}} &amp;= \frac{\partial\ell}{\partial\ell^{\langle t\rangle}} {\color{Red}{ \frac{\partial\ell^{\langle t\rangle}}{\partial\hat{y}^{\langle t\rangle}} \frac{\partial\hat{y}^{\langle t\rangle}}{\partial z2^{\langle t\rangle}} }} \frac{\partial z2^{\langle t\rangle}}{\partial a^{\langle t\rangle}} \frac{\partial a^{\langle t\rangle}}{\partial z1^{\langle t\rangle}} \frac{\partial z1^{\langle t\rangle}}{\partial W_{ax}}\\ &amp;= {\color{Red}{ (\hat{y}^{\langle t\rangle}-y^{\langle t\rangle}) }} W_{ya} (1-\tanh^2(z1^{\langle t\rangle})) x^{\langle t\rangle} \end{split}\] <p>我们就可以得到在最后时刻 \(t\) 参数 \(W_{ax}\) 的偏导数。</p> <blockquote> <p>关于上面式子中的偏导数的计算，除了标量对矩阵的求导，在后面还包括了两个一个矩阵或向量对另一个矩阵或向量中的求导，实际上这是非常麻烦的一件事。</p> <p>比如在计算 \(\frac{\partial z1^{\langle t\rangle}}{\partial W_{ax}}\) 偏导数的时候，我们发现 \(z1^{\langle t\rangle}\) 是一个 \(\mathbb{R}^{n_a\times m}\) 的矩阵，而 \(W_{ax}\) 则是一个 \(\mathbb{R}^{n_a\times n_x}\) 的矩阵，这一项就是一个矩阵对另一个矩阵求偏导，如果直接对其求导我们将会得到一个四维的矩阵 \(\mathbb{R}^{n_a\times n_x\times n_a\times m}\) （<em>雅可比矩阵 Jacobian matrix</em>）；只不过这个高维矩阵中偏导数的值有很多 \(0\) 。</p> <p>在神经网络中，如果直接将这个高维矩阵直接生搬硬套进梯度下降里更新参数是不可行，因为我们需要得到的梯度是关于自变量同型的向量或矩阵而且我们还要处理更高维度的矩阵的乘法；所以我们需要将结果进行一定的处理得到我们仅仅需要的信息。</p> <p>一般在深度学习框架中都会有自动求梯度的功能包，这些包（比如 <code class="language-plaintext highlighter-rouge">PyTorch</code> ）中就只允许一个标量对向量或矩阵求导，其他情况是不允许的，除非在反向传播的函数里传入一个同型的权重向量或矩阵才可以得到导数。</p> </blockquote> <p>我们先简单求出一个偏导数 \(\frac{\partial\ell}{\partial W_{ax}}\) 我们下面使用 <code class="language-plaintext highlighter-rouge">PyTorch</code> 中的自动求梯度的包进行验证我们的公式是否正确。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 这是神经网络中的一些架构的参数
</span><span class="n">n_x</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">n_y</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">T_x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">T_y</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">n_a</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 定义所有参数矩阵
# requires_grad 为 True 表明在涉及这个变量的运算时建立计算图
# 为了之后反向传播求导
</span><span class="n">W_ax</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_a</span><span class="p">,</span> <span class="n">n_x</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">W_aa</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_a</span><span class="p">,</span> <span class="n">n_a</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ba</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_a</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">W_ya</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_y</span><span class="p">,</span> <span class="n">n_a</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">by</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_y</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># t 时刻的输入和上一时刻的 hidden state
</span><span class="n">x_t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_x</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">a_prev</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_a</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">y_t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">((</span><span class="n">n_y</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 开始模拟一个神经元 t 时刻的前向传播
# 从输入一直到计算出 loss
</span><span class="n">z1_t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">W_ax</span><span class="p">,</span> <span class="n">x_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">W_aa</span><span class="p">,</span> <span class="n">a_prev</span><span class="p">)</span> <span class="o">+</span> <span class="n">ba</span>
<span class="n">z1_t</span><span class="p">.</span><span class="nf">retain_grad</span><span class="p">()</span>
<span class="n">a_t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">z1_t</span><span class="p">)</span>
<span class="n">a_t</span><span class="p">.</span><span class="nf">retain_grad</span><span class="p">()</span>
<span class="n">z2_t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">W_ya</span><span class="p">,</span> <span class="n">a_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">by</span>
<span class="n">z2_t</span><span class="p">.</span><span class="nf">retain_grad</span><span class="p">()</span>
<span class="n">y_hat</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">z2_t</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">z2_t</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">y_hat</span><span class="p">.</span><span class="nf">retain_grad</span><span class="p">()</span>
<span class="n">loss_t</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">y_t</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">y_hat</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">loss_t</span><span class="p">.</span><span class="nf">retain_grad</span><span class="p">()</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 对最后的 loss 标量开始进行反向传播求导
</span><span class="n">loss_t</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 我们就可以得到 W_ax 的导数
# 存储在后缀 _autograd 变量中，表明是由框架自动求导得到的
</span><span class="n">W_ax_autograd</span> <span class="o">=</span> <span class="n">W_ax</span><span class="p">.</span><span class="n">grad</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 查看框架计算得到的导数
</span><span class="n">W_ax_autograd</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tensor([[ 0.5252,  1.1938, -0.2352,  1.1571, -1.0168,  0.3195],
        [-1.0536, -2.3949,  0.4718, -2.3213,  2.0398, -0.6410],
        [-0.0316, -0.0717,  0.0141, -0.0695,  0.0611, -0.0192]])
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 我们对自己推演出的公式进行手动计算导数
# 存储在后缀 _manugrad 变量中，表明是手动由公式计算得到的
</span><span class="n">W_ax_manugrad</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">((</span><span class="n">y_hat</span> <span class="o">-</span> <span class="n">y_t</span><span class="p">).</span><span class="n">T</span><span class="p">,</span> <span class="n">W_ya</span><span class="p">).</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">torch</span><span class="p">.</span><span class="nf">square</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">z1_t</span><span class="p">))),</span> <span class="n">x_t</span><span class="p">.</span><span class="n">T</span><span class="p">)</span>
<span class="c1">#torch.matmul(torch.matmul(W_ya.T, y_hat - y_t) * (1 - torch.square(torch.tanh(z1_t))), x_t.T)
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 输出手动计算的导数
</span><span class="n">W_ax_manugrad</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tensor([[ 0.5195,  1.1809, -0.2327,  1.1447, -1.0058,  0.3161],
        [-1.0195, -2.3172,  0.4565, -2.2461,  1.9737, -0.6202],
        [-0.0309, -0.0703,  0.0138, -0.0681,  0.0599, -0.0188]],
       grad_fn=&lt;MmBackward&gt;)
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 查看两种求导结果的之差的 L2 范数
</span><span class="n">torch</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">W_ax_manugrad</span> <span class="o">-</span> <span class="n">W_ax_autograd</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tensor(0.1356, grad_fn=&lt;CopyBackwards&gt;)
</code></pre></div></div> <p>通过上面的编程输出可以看到，我们手动计算的导数和框架自己求出的导数虽然有一定的误差，但是一一对照可以大体看到我们手动求出来的导数大体是对的，并没有说错的非常离谱。</p> <p>但上面只是当 \(t=T_x\) 即 \(t\) 时刻是最后一个输入单元的时候，也就是说所求的关于 \(_W{ax}\) 的导数只是全部导数的一部分，因为参数共享，所以每一时刻的神经元都有对 \(W_{ax}\) 的导数，所以需要将所有时刻的神经元关于 \(W_{ax}\) 的导数全部加起来。</p> <p>若 \(t\) 不是最后一时刻，可能是神经网络里的中间的某一时刻的神经元；也就是说，在进行反向传播的时候，想要求 \(t\) 时刻的导数，就得等到 \(t+1\) 时刻的导数值传进来，然后根据链式法则才可以计算当前时刻参数的导数。</p> <p>下面是一个简易的计算图，只绘制出了 \(W_ax\) 到 \(\ell\) 的计算中，共涉及到哪些变量（在整个神经网络中的 \(W_{ax}\) 的权重参数是共享的）：</p> <p><img src="https://tva2.sinaimg.cn/large/006VTcCxly1gmizn9a86aj318y0t8goe.jpg" alt="image"/></p> <p>下面使用一个视频展示整个神经网络中从 \(W_{ax}\) 到一个数据批量的损失值 \(\ell\) 的大体流向：</p> <p><img src="https://yun.zyxweb.cn/index.php?explorer/share/file&amp;hash=1439457NtxPsb8asnr_vVtY66j-3v_8NDjbXDkWQTo-Tq5zESZQQZxsY&amp;name=forward.mp4" alt="forward.mp4"/></p> <p>计算完 \(\ell\) 之后就可以计算 \(\frac{\partial\ell}{\partial W_{ax}}\) 的导数值，但是 RNN 神经网络的反向传播区别于全连接神经网络的。</p> <p><img src="https://tvax2.sinaimg.cn/large/006VTcCxly1gmj0k2u79mj31980swacc.jpg" alt="image"/></p> <p>然后，我们演示一下如何进行反向传播的，注意看每一个时刻的 \(a^{\langle t\rangle}\) 的计算都是等 \(a^{\langle t+1\rangle}\) 的导数值传进来才进行计算的；同样地，\(W_{ax}\) 导数的计算也不是一步到位的，也是需要等到所有时刻的 \(a\) 的值全部传到才计算完。</p> <p><img src="https://yun.zyxweb.cn/index.php?explorer/share/file&amp;hash=1fc3U3bwTyfi-h40ykZa-0dfBrIcvkwjhXDDD_fGLGyO7xj52MiHSxWa&amp;name=backward.mp4" alt="backward.mp4"/></p> <p>所以对于神经网络中间某一个单元 \(t\) 我们有：</p> \[\begin{split} \frac{\partial\ell}{\partial W_{ax}} &amp;= {\color{Red}{ \left( \frac{\partial\ell}{\partial a^{\langle t\rangle}} +\frac{\partial\ell}{\partial z1^{\langle t+1\rangle}} \frac{\partial z1^{\langle t+1\rangle}}{\partial a^{\langle t\rangle}} \right) }} \frac{\partial a^{\langle t\rangle}}{\partial z1^{\langle t\rangle}} \frac{\partial z1^{\langle t\rangle}}{\partial W_{ax}} \end{split}\] <p>关于红色的部分的意思是需要等到 \(t+1\) 时刻的导数值传进来，然后才可以进行对 \(t+1\) 时刻关于当前时刻 \(t\) 的参数求导，最后得到参数梯度的一个分量。其实若仔细展开每一个偏导项，就像是一个递归一样，每次求某一时刻的导数总是要从最后一时刻往前传到当前时刻才可以进行。</p> <blockquote> <p><strong>多元复合函数的求导法则</strong></p> <p>如果函数 \(u=\varphi(t)\) 及 \(v=\psi(t)\) 都在点 \(t\) 可导，函数 \(z=f(u,v)\) 在对应点 \((u,v)\) 具有连续偏导数，那么复合函数 \(z=f[\varphi(t),\psi(t)]\) 在点 \(t\) 可导，且有 \(\frac{\mathrm{d}z}{\mathrm{d}t}=\frac{\partial z}{\partial u}\frac{\mathrm{d}u}{\mathrm{d}t}+\frac{\partial z}{\partial v}\frac{\mathrm{d}v}{\mathrm{d}t}\)</p> </blockquote> <p>下面使用一张计算图说明 \(a^{\langle t\rangle}\) 到 \(\ell\) 的计算关系。</p> <p><img src="https://tvax4.sinaimg.cn/large/006VTcCxly1gmjsx4kqcqj30w80audg6.jpg" alt="image"/></p> <p>也就是说第 \(t\) 时刻 \(\ell\) 关于 \(a^{\langle t\rangle}\) 的导数是由两部分相加组成，也就是说是由两条路径反向传播，这两条路径分别是 \(\ell\to\ell^{\langle t\rangle}\to\hat{y}^{\langle t\rangle}\to z2^{\langle t\rangle}\to a^{\langle t\rangle}\) 和 \(\ell\to\ell^{\langle t+1\rangle}\to\hat{y}^{\langle t+1\rangle}\to z2^{\langle t+1\rangle}\to a^{\langle t+1\rangle}\to z1^{\langle t+1\rangle}\to a^{\langle t\rangle}\) ，我们将这两条路径导数之和使用 \(\mathrm{d}a_{\mathrm{next}}\) 表示。</p> <p>所以我们可以得到在中间某一时刻的神经单元关于 \(W_{ax}\) 的导数为：</p> \[\frac{\partial\ell}{\partial W_{ax}}=\left(\mathrm{d}a_{\mathrm{next}} * \left( 1-\tanh^2(z1^{\langle t \rangle}\right)\right) x^{\langle t \rangle T}\] <p>通过同样的方法，我们就可以得到其它参数的导数：</p> \[\begin{align} \frac{\partial\ell}{\partial W_{aa}} &amp;= \left(\mathrm{d}a_{\mathrm{next}} * \left( 1-\tanh^2(z1^{\langle t\rangle}) \right)\right) a^{\langle t-1 \rangle T}\\ \frac{\partial\ell}{\partial b_a} &amp; = \sum_{batch}\left( da_{next} * \left( 1-\tanh^2(z1^{\langle t\rangle}) \right)\right)\\ \end{align}\] <p>除了传递参数的导数，在第 \(t\) 时刻还需要传送 \(\ell\) 关于 \(z1^{\langle t\rangle}\) 的导数到 \(t-1\) 时刻，将需要传送到上一时刻的导数记作为 \(\mathrm{d}a_{\mathrm{prev}}\) 我们得到：</p> \[\begin{split} \mathrm{d}a_{\mathrm{prev}} &amp;= \mathrm{d}a_\mathrm{next}\frac{\partial a^{\langle t\rangle}}{\partial z1^{\langle t\rangle}}\frac{\partial z1^{\langle t\rangle}}{\partial a^{\langle t-1\rangle}}\\ &amp;= { W_{aa}}^T\left(\mathrm{d}a_{\mathrm{next}} * \left( 1-\tanh^2(z1^{\langle t\rangle}) \right)\right) \end{split}\] <p>可以看到，一个循环神经网络的反向传播实际上是非常复杂的，因为每一时刻的神经元都与参数有计算关系，所以反向传播时的路径非常杂乱，其中还涉及到了高维的矩阵，所以在计算时需要对高维矩阵进行一定的矩阵代数转换才方便导数和更新参数的计算。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry></feed>