<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://jkfx.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jkfx.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-03-11T13:50:45+00:00</updated><id>https://jkfx.github.io/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">Python 不太简短的介绍</title><link href="https://jkfx.github.io/blog/2025/Python%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D/" rel="alternate" type="text/html" title="Python 不太简短的介绍"/><published>2025-03-09T11:05:00+00:00</published><updated>2025-03-09T11:05:00+00:00</updated><id>https://jkfx.github.io/blog/2025/Python%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="https://jkfx.github.io/blog/2025/Python%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D/"><![CDATA[<h2 id="python-简介">Python 简介</h2> <p>Python 虽然简单易用，但它可是真正的编程语言，提供了大量的数据结构，也支持开发大型程序，远超 shell 脚本或批处理文件；Python 提供的错误检查比 C 还多；作为一种“非常高级的语言”，它内置了灵活的数组与字典等高级数据类型。正因为配备了更通用的数据类型，Python 比 Awk，甚至 Perl 能解决更多问题，而且，很多时候，Python 比这些语言更简单。</p> <p>顺便提一句，Python 语言的命名源自 BBC 的 “Monty Python 飞行马戏团”，与爬行动物无关（Python 原义为“蟒蛇”）。</p> <h2 id="python-解释器">Python 解释器</h2> <p>在主提示符中，输入文件结束符（Unix 里是 Control-D，Windows 里是 Control-Z），就会退出解释器，退出状态码为 0。如果不能退出，还可以输入这个命令：quit()。</p> <p>在支持 GNU Readline 库的系统中，解释器的行编辑功能包括交互式编辑、历史替换、代码补全等。检测是否支持命令行编辑最快速的方式是，在首次出现 Python 提示符时，输入 Control-P。听到“哔”提示音，说明支持行编辑。如果没有反应，或回显了 ^P，则说明不支持行编辑；只能用退格键删除当前行的字符。</p> <p>解释器的操作方式类似 Unix Shell：用与 tty 设备关联的标准输入调用时，可以交互式地读取和执行命令；以文件名参数，或标准输入文件调用时，则读取并执行文件中的 脚本。</p> <p>另一种启动解释器的方式是 python -c command [arg] …，这将执行 command 中的语句，相当于 shell 的 -c 选项。 由于 Python 语句经常包含空格或其他会被 shell 特殊对待的字符，通常建议用引号将整个 command 括起来。</p> <p>Python 模块也可以当作脚本使用。输入：python -m module [arg] …，会执行 module 的源文件，这跟在命令行把路径写全了一样。</p> <p>在交互模式下运行脚本文件，只要在脚本名称参数前，加上选项 -i 就可以了。</p> <p>默认情况下，Python 源码文件的编码是 UTF-8。这种编码支持世界上大多数语言的字符，可以用于字符串字面值、变量、函数名及注释 —— 尽管标准库只用常规的 ASCII 字符作为变量名或函数名，可移植代码都应遵守此约定。要正确显示这些字符，编辑器必须能识别 UTF-8 编码，而且必须使用支持文件中所有字符的字体。</p> <p>如果不使用默认编码，则要声明文件的编码，文件的 第一 行要写成特殊注释。句法如下：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: encoding -*-
</span></code></pre></div></div> <p>其中，encoding 可以是 Python 支持的任意一种 <a href="https://docs.python.org/zh-cn/3.11/library/codecs.html#standard-encodings">codecs</a>。</p> <p>在 BSD 等类Unix系统上，Python 脚本可以像 shell 脚本一样直接执行，通过在第一行添加，此时，编码声明要写在文件的第二行。例如：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
# -*- coding: cp1252 -*-
</span></code></pre></div></div> <h2 id="python-速览">Python 速览</h2> <p>Python 注释以 # 开头，直到该物理行结束。注释可以在行开头，或空白符与代码之后，但不能在字符串里面。字符串中的 # 号就是 # 号。注释用于阐明代码，Python 不解释注释，键入例子时，可以不输入注释。</p> <p>示例如下：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># this is the first comment
</span><span class="n">spam</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># and this is the second comment
</span>          <span class="c1"># ... and now a third!
</span><span class="n">text</span> <span class="o">=</span> <span class="sh">"</span><span class="s"># This is not a comment because it</span><span class="sh">'</span><span class="s">s inside quotes.</span><span class="sh">"</span>
</code></pre></div></div> <h3 id="数字">数字</h3> <p>除法运算 (/) 总是返回浮点数。 如果要做 floor division 得到一个整数结果你可以使用 // 运算符；要计算余数你可以使用 %。用 ** 运算符计算乘方。</p> <p>交互模式下，上次输出的表达式会赋给变量 _。把 Python 当作计算器时，用该变量实现下一步计算更简单。最好把该变量当作只读类型。不要为它显式赋值，否则会创建一个同名独立局部变量，该变量会用它的魔法行为屏蔽内置变量。</p> <p>除了 int 和 float，Python 还支持其他数字类型，例如 <a href="https://docs.python.org/zh-cn/3.11/library/decimal.html#decimal.Decimal">Decimal</a> 或 <a href="https://docs.python.org/zh-cn/3.11/library/fractions.html#fractions.Fraction">Fraction</a>。Python 还内置支持 复数，后缀 j 或 J 用于表示虚数（例如 3+5j ）。</p> <h3 id="文本">文本</h3> <p>除了数字 Python 还可以操作文本（由 str 类型表示，称为“字符串”）。 这包括字符 “!”, 单词 “rabbit”, 名称 “Paris”, 句子 “Got your back.” 等等. “Yay! :)”。 它们可以用成对的单引号 (‘…’) 或双引号 (“…”) 来标示，结果完全相同。</p> <p>要标示引号本身，我们需要对它进行“转义”，即在前面加一个 \。 或者，我们也可以使用不同类型的引号。</p> <p>如果不希望前置 \ 的字符转义成特殊字符，可以使用 原始字符串，在引号前添加 r 即可：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">C:\some</span><span class="se">\n</span><span class="s">ame</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># here \n means newline!
</span><span class="n">C</span><span class="p">:</span>\<span class="n">some</span>
<span class="n">ame</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">C:\some\name</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># note the r before the quote
</span><span class="n">C</span><span class="p">:</span>\<span class="n">some</span>\<span class="n">name</span>
</code></pre></div></div> <p>原始字符串还有一个微妙的限制：一个原始字符串不能以奇数个 \ 字符结束；请参阅 <a href="https://docs.python.org/zh-cn/3.11/faq/programming.html#faq-programming-raw-string-backslash">此 FAQ 条目</a> 了解更多信息及绕过的办法。</p> <p>字符串字面值可以包含多行。 一种实现方式是使用三重引号：”"”…””” 或 ‘'’…’’‘。 字符串中将自动包括行结束符，但也可以在换行的地方添加一个 \ 来避免此情况。 参见以下示例：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="sh">"""</span><span class="se">\
</span><span class="s">Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
</span><span class="sh">"""</span><span class="p">)</span>
</code></pre></div></div> <p>输出如下（请注意开始的换行符没有被包括在内）：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
</code></pre></div></div> <p>字符串可以用 + 合并（粘到一起），也可以用 * 重复。</p> <p>相邻的两个或多个 字符串字面值 （引号标注的字符）会自动合并：</p> <p>拼接分隔开的长字符串时，这个功能特别实用：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="sh">'</span><span class="s">Put several strings within parentheses </span><span class="sh">'</span>

        <span class="sh">'</span><span class="s">to have them joined together.</span><span class="sh">'</span><span class="p">)</span>

<span class="n">text</span>
<span class="sh">'</span><span class="s">Put several strings within parentheses to have them joined together.</span><span class="sh">'</span>
</code></pre></div></div> <p>这项功能只能用于两个字面值，不能用于变量或表达式。合并多个变量，或合并变量与字面值，要用 + 。</p> <p>字符串支持 索引 （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的字符串。索引还支持负数，用负数索引时，从右边开始计数。</p> <p>In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters, slicing allows you to obtain substring.</p> <p>切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾。注意，输出结果包含切片开始，但不包含切片结束。因此，s[:i] + s[i:] 总是等于 s 。</p> <p>还可以这样理解切片，索引指向的是字符 之间 ，第一个字符的左侧标为 0，最后一个字符的右侧标为 n ，n 是字符串长度。例如：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
</code></pre></div></div> <p>第一行数字是字符串中索引 0…6 的位置，第二行数字是对应的负数索引位置。i 到 j 的切片由 i 和 j 之间所有对应的字符组成。</p> <p>对于使用非负索引的切片，如果两个索引都不越界，切片长度就是起止索引之差。例如， word[1:3] 的长度是 2。</p> <p>索引越界会报错，但是，切片会自动处理越界索引。</p> <p>Python 字符串不能修改，是 <a href="https://docs.python.org/zh-cn/3.11/glossary.html#term-immutable">immutable</a> 的。因此，为字符串中某个索引位置赋值会报错。</p> <p>要生成不同的字符串，应新建一个字符串。内置函数 len() 返回字符串的长度。</p> <h3 id="列表">列表</h3> <p>列表 可以包含不同类型的元素，但一般情况下，各个元素的类型相同。和字符串（及其他内置 <a href="https://docs.python.org/zh-cn/3.11/glossary.html#term-sequence">sequence</a> 类型）一样，列表也支持索引和切片。</p> <p>列表还支持合并操作：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">squares</span> <span class="o">+</span> <span class="p">[</span><span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
</code></pre></div></div> <p>与 immutable 字符串不同, 列表是 <a href="https://docs.python.org/zh-cn/3.11/glossary.html#term-mutable">mutable</a> 类型，其内容可以改变：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cubes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">125</span><span class="p">]</span>  <span class="c1"># something's wrong here
</span>
<span class="mi">4</span> <span class="o">**</span> <span class="mi">3</span>  <span class="c1"># the cube of 4 is 64, not 65!
</span><span class="mi">64</span>

<span class="n">cubes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64</span>  <span class="c1"># replace the wrong value
</span>
<span class="n">cubes</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">125</span><span class="p">]</span>
</code></pre></div></div> <p>你也可以在通过使用 list.append() 方法，在列表末尾添加新条目。</p> <p>Python 中的简单赋值绝不会复制数据。 当你将一个列表赋值给一个变量时，该变量将引用 现有的列表。你通过一个变量对列表所做的任何更改都会被引用它的所有其他变量看到。</p> <p>切片操作返回包含请求元素的新列表。以下切片操作会返回列表的 <a href="https://docs.python.org/zh-cn/3.11/library/copy.html#shallow-vs-deep-copy">浅拷贝</a>：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">correct_rgba</span> <span class="o">=</span> <span class="n">rgba</span><span class="p">[:]</span>

<span class="n">correct_rgba</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Alpha</span><span class="sh">"</span>

<span class="n">correct_rgba</span>
<span class="p">[</span><span class="sh">"</span><span class="s">Red</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Green</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Blue</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Alpha</span><span class="sh">"</span><span class="p">]</span>

<span class="n">rgba</span>
<span class="p">[</span><span class="sh">"</span><span class="s">Red</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Green</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Blue</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Alph</span><span class="sh">"</span><span class="p">]</span>
</code></pre></div></div> <p>为切片赋值可以改变列表大小，甚至清空整个列表：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">e</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">]</span>

<span class="n">letters</span>
<span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">e</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">]</span>

<span class="c1"># replace some values
</span>
<span class="n">letters</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">D</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">E</span><span class="sh">'</span><span class="p">]</span>

<span class="n">letters</span>
<span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">D</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">E</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">]</span>

<span class="c1"># now remove them
</span>
<span class="n">letters</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">letters</span>
<span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">f</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">]</span>

<span class="c1"># clear the list by replacing all the elements with an empty list
</span>
<span class="n">letters</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">letters</span>
<span class="p">[]</span>
</code></pre></div></div> <p>内置函数 len() 也支持列表。还可以嵌套列表（创建包含其他列表的列表）。</p> <h2 id="控制流工具">控制流工具</h2> <h3 id="if-语句">if 语句</h3> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">(</span><span class="sh">"</span><span class="s">Please enter an integer: </span><span class="sh">"</span><span class="p">))</span>

<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Negative changed to zero</span><span class="sh">'</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Zero</span><span class="sh">'</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Single</span><span class="sh">'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">More</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <h3 id="for-语句">for 语句</h3> <p>Python 的 for 语句与 C 或 Pascal 中的不同。Python 的 for 语句不迭代算术递增数值（如 Pascal），或是给予用户定义迭代步骤和结束条件的能力（如 C），而是在列表或字符串等任意序列的元素上迭代，按它们在序列中出现的顺序。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">cat</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">window</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">defenestrate</span><span class="sh">'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
</code></pre></div></div> <p>很难正确地在迭代多项集的同时修改多项集的内容。更简单的方法是迭代多项集的副本或者创建新的多项集：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a sample collection
</span><span class="n">users</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">Hans</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">active</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Éléonore</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">inactive</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">景太郎</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">active</span><span class="sh">'</span><span class="p">}</span>

<span class="c1"># Strategy:  Iterate over a copy
</span><span class="k">for</span> <span class="n">user</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">users</span><span class="p">.</span><span class="nf">copy</span><span class="p">().</span><span class="nf">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="sh">'</span><span class="s">inactive</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">users</span><span class="p">[</span><span class="n">user</span><span class="p">]</span>

<span class="c1"># Strategy:  Create a new collection
</span><span class="n">active_users</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">user</span><span class="p">,</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">users</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="sh">'</span><span class="s">active</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">active_users</span><span class="p">[</span><span class="n">user</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span>
</code></pre></div></div> <h3 id="range-函数">range() 函数</h3> <p>内置函数 <a href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#range">range()</a> 用于生成等差数列。</p> <p>生成的序列绝不会包括给定的终止值；range(10) 生成 10 个值——长度为 10 的序列的所有合法索引。range 可以不从 0 开始，且可以按给定的步长递增（即使是负数步长）。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">))</span>
</code></pre></div></div> <p>要按索引迭代序列，可以组合使用 range() 和 len() 。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">Mary</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">had</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">little</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">lamb</span><span class="sh">'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</code></pre></div></div> <p>不过大多数情况下 <a href="https://docs.python.org/zh-cn/3.11/library/functions.html#enumerate">enumerate()</a> 函数很方便。</p> <p>如果直接打印一个 range 会发生意想不到的事情。range() 返回的对象在很多方面和列表的行为一样，但其实它和列表不一样。该对象只有在被迭代时才一个一个地返回所期望的列表项，并没有真正生成过一个含有全部项的列表，从而节省了空间。</p> <p>这种对象称为可迭代对象 iterable，适合作为需要获取一系列值的函数或程序构件的参数。for 语句就是这样的程序构件；以可迭代对象作为参数的函数例如 <a href="https://docs.python.org/zh-cn/3.11/library/functions.html#sum">sum()</a> 。</p> <h3 id="循环中的-breakcontinue-语句及-else-子句">循环中的 break、continue 语句及 else 子句</h3> <p>break 语句将跳出最近的一层 for 或 while 循环。</p> <p>for 或 while 循环可以包括 else 子句。</p> <p>在 for 循环中，else 子句会在循环成功结束最后一次迭代之后执行。</p> <p>在 while 循环中，它会在循环条件变为假值后执行。</p> <p>无论哪种循环，如果因为 break 而结束，那么 else 子句就 不会 执行。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="sh">'</span><span class="s">equals</span><span class="sh">'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">,</span> <span class="n">n</span><span class="o">//</span><span class="n">x</span><span class="p">)</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># loop fell through without finding a factor
</span>        <span class="nf">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="sh">'</span><span class="s">is a prime number</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p>else 子句用于循环时比起 if 语句的 else 子句，更像 try 语句的。try 语句的 else 子句在未发生异常时执行，循环的 else 子句则在未发生 break 时执行。</p> <p>continue 语句，同样借鉴自 C 语言，以执行循环的下一次迭代来继续。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Found an even number</span><span class="sh">"</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">continue</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Found an odd number</span><span class="sh">"</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
</code></pre></div></div> <h3 id="pass-语句">pass 语句</h3> <p>pass 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">pass</span>  <span class="c1"># Busy-wait for keyboard interrupt (Ctrl+C)
</span></code></pre></div></div> <p>这常用于创建一个最小的类。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyEmptyClass</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></div></div> <p>pass 还可用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。pass 会被默默地忽略。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initlog</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">pass</span>   <span class="c1"># Remember to implement this!
</span></code></pre></div></div> <h3 id="match-语句">match 语句</h3> <p>match 语句接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较。这表面上像 C、Java 或 JavaScript（以及许多其他程序设计语言）中的 switch 语句，但其实它更像 Rust 或 Haskell 中的模式匹配。只有第一个匹配的模式会被执行，并且它还可以提取值的组成部分（序列的元素或对象的属性）赋给变量。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">http_error</span><span class="p">(</span><span class="n">status</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">status</span><span class="p">:</span>
        <span class="n">case</span> <span class="mi">400</span><span class="p">:</span>
            <span class="k">return</span> <span class="sh">"</span><span class="s">Bad request</span><span class="sh">"</span>
        <span class="n">case</span> <span class="mi">404</span><span class="p">:</span>
            <span class="k">return</span> <span class="sh">"</span><span class="s">Not found</span><span class="sh">"</span>
        <span class="n">case</span> <span class="mi">418</span><span class="p">:</span>
            <span class="k">return</span> <span class="sh">"</span><span class="s">I</span><span class="sh">'</span><span class="s">m a teapot</span><span class="sh">"</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="sh">"</span><span class="s">Something</span><span class="sh">'</span><span class="s">s wrong with the internet</span><span class="sh">"</span>
</code></pre></div></div> <p>注意最后一个代码块：“变量名” _ 被作为 通配符 并必定会匹配成功。如果没有 case 匹配成功，则不会执行任何分支。</p> <table> <tbody> <tr> <td>你可以使用</td> <td>（“ or ”）在一个模式中组合几个字面值</td> </tr> </tbody> </table> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">case</span> <span class="mi">401</span> <span class="o">|</span> <span class="mi">403</span> <span class="o">|</span> <span class="mi">404</span><span class="p">:</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">Not allowed</span><span class="sh">"</span>
</code></pre></div></div> <p>形如解包赋值的模式可被用于绑定变量。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># point is an (x, y) tuple
</span><span class="n">match</span> <span class="n">point</span><span class="p">:</span>
    <span class="nf">case </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Origin</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">case </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">case </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">case </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s">, Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Not a point</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>请仔细学习此代码！第一个模式有两个字面值，可视为前述字面值模式的扩展。接下来的两个模式结合了一个字面值和一个变量，变量 绑定 了来自主语（point）的一个值。第四个模式捕获了两个值，使其在概念上与解包赋值 (x, y) = point 类似。</p> <p>如果用类组织数据，可以用“类名后接一个参数列表”这种很像构造器的形式，把属性捕获到变量里。</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">where_is</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">point</span><span class="p">:</span>
        <span class="n">case</span> <span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Origin</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">case</span> <span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Y=</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">case</span> <span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">X=</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">case</span> <span class="nc">Point</span><span class="p">():</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Somewhere else</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Not a point</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>你可以在某些为其属性提供了排序的内置类（例如 dataclass）中使用位置参数。 你也可以通过在你的类中设置 __match_args__ 特殊属性来为模式中的属性定义一个专门的位置。 如果它被设为 (“x”, “y”)，则以下模式均为等价的（并且都是将 y 属性绑定到 var 变量）:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
<span class="nc">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
<span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
<span class="nc">Point</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <p>建议这样来阅读一个模式——通过将其视为赋值语句等号左边的一种扩展形式，来理解各个变量被设为何值。match 语句只会为单一的名称（如上面的 var）赋值，而不会赋值给带点号的名称（如 foo.bar）、属性名（如上面的 x= 和 y=）和类名（是通过其后的 “(…)” 来识别的，如上面的 Point）。</p> <p>模式可以任意嵌套。举例来说，如果我们有一个由 Point 组成的列表，且 Point 添加了 __match_args__ 时，我们可以这样来匹配它：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">__match_args__</span> <span class="o">=</span> <span class="p">(</span><span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

<span class="n">match</span> <span class="n">points</span><span class="p">:</span>
    <span class="n">case</span> <span class="p">[]:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">No points</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">case</span> <span class="p">[</span><span class="nc">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">The origin</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">case</span> <span class="p">[</span><span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Single point </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">case</span> <span class="p">[</span><span class="nc">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="nc">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y2</span><span class="p">)]:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Two on the Y axis at </span><span class="si">{</span><span class="n">y1</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">y2</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Something else</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>我们可以向一个模式添加 if 子句，称为“约束项”。 如果约束项为假值，则 match 将继续尝试下一个 case 语句块。 请注意值的捕获发生在约束项被求值之前:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">match</span> <span class="n">point</span><span class="p">:</span>
    <span class="n">case</span> <span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Y=X at </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">case</span> <span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Not on the diagonal</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h3 id="定义函数">定义函数</h3> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>    <span class="c1"># write Fibonacci series up to n
</span>    <span class="sh">"""</span><span class="s">Print a Fibonacci series up to n.</span><span class="sh">"""</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
    <span class="nf">print</span><span class="p">()</span>

<span class="c1"># Now call the function we just defined:
</span><span class="nf">fib</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span>
</code></pre></div></div> <p>定义 函数使用关键字 def，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩进。</p> <p>函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring，详见 文档字符串。利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档；Python 开发者最好养成在代码中加入文档字符串的好习惯。</p> <p>函数在 执行 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是 <a href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#global">global</a> 语句定义的全局变量，或 <a href="https://docs.python.org/zh-cn/3.11/reference/simple_stmts.html#nonlocal">nonlocal</a> 语句定义的外层函数变量）。</p> <p>在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 按值调用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）。 当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表。</p> <p>函数定义在当前符号表中把函数名与函数对象关联在一起。解释器把函数名指向的对象作为用户自定义函数。还可以使用其他名称指向同一个函数对象，并访问访该函数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fib</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">fib</span> <span class="n">at</span> <span class="mi">10042</span><span class="n">ed0</span><span class="o">&gt;</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">fib</span>

<span class="nf">f</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="mi">13</span> <span class="mi">21</span> <span class="mi">34</span> <span class="mi">55</span> <span class="mi">89</span>
</code></pre></div></div> <p>如果你用过其他语言，你可能会认为 fib 不是函数而是一个过程，因为它没有返回值。 事实上，即使没有 return 语句的函数也有返回值，尽管这个值可能相当无聊。 这个值被称为 None (是一个内置名称)。 通常解释器会屏蔽单独的返回值 None。 如果你确有需要可以使用 print() 查看它:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">fib</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">fib</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="bp">None</span>
</code></pre></div></div> <h3 id="函数定义详解">函数定义详解</h3> <p>函数定义支持可变数量的参数。这里列出三种可以组合使用的形式。</p> <h4 id="默认值参数">默认值参数</h4> <p>为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ask_ok</span><span class="p">(</span><span class="n">prompt</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">reminder</span><span class="o">=</span><span class="sh">'</span><span class="s">Please try again!</span><span class="sh">'</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="nf">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ok</span> <span class="ow">in</span> <span class="p">(</span><span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ye</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">yes</span><span class="sh">'</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">ok</span> <span class="ow">in</span> <span class="p">(</span><span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">no</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">nop</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">nope</span><span class="sh">'</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">retries</span> <span class="o">=</span> <span class="n">retries</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">invalid user response</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">reminder</span><span class="p">)</span>
</code></pre></div></div> <p>该函数可以用以下方式调用：</p> <ul> <li>只给出必选实参：ask_ok(‘Do you really want to quit?’)</li> <li>给出一个可选实参：ask_ok(‘OK to overwrite the file?’, 2)</li> <li>给出所有实参：ask_ok(‘OK to overwrite the file?’, 2, ‘Come on, only yes or no!’)</li> </ul> <p>本例还使用了关键字 <a href="https://docs.python.org/zh-cn/3.11/reference/expressions.html#in">in</a> ，用于确认序列中是否包含某个值。</p> <p>默认值在 定义 作用域里的函数定义中求值，所以：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">6</span>
<span class="nf">f</span><span class="p">()</span>
</code></pre></div></div> <p>上例输出的是 5。</p> <p>重要警告： 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">L</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</code></pre></div></div> <p>输出结果如下：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1]
[1, 2]
[1, 2, 3]
</code></pre></div></div> <p>不想在后续调用之间共享默认值时，应以如下方式编写函数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</code></pre></div></div> <h4 id="关键字参数">关键字参数</h4> <p>kwarg=value 形式的 关键字参数 也可以用于调用函数。函数示例如下：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parrot</span><span class="p">(</span><span class="n">voltage</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="sh">'</span><span class="s">a stiff</span><span class="sh">'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">'</span><span class="s">voom</span><span class="sh">'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="sh">'</span><span class="s">Norwegian Blue</span><span class="sh">'</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-- This parrot wouldn</span><span class="sh">'</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">if you put</span><span class="sh">"</span><span class="p">,</span> <span class="n">voltage</span><span class="p">,</span> <span class="sh">"</span><span class="s">volts through it.</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-- Lovely plumage, the</span><span class="sh">"</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-- It</span><span class="sh">'</span><span class="s">s</span><span class="sh">"</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="sh">"</span><span class="s">!</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>该函数接受一个必选参数（voltage）和三个可选参数（state, action 和 type）。该函数可用下列方式调用：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parrot</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>                                          <span class="c1"># 1 positional argument
</span><span class="nf">parrot</span><span class="p">(</span><span class="n">voltage</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>                                  <span class="c1"># 1 keyword argument
</span><span class="nf">parrot</span><span class="p">(</span><span class="n">voltage</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">'</span><span class="s">VOOOOOM</span><span class="sh">'</span><span class="p">)</span>             <span class="c1"># 2 keyword arguments
</span><span class="nf">parrot</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="sh">'</span><span class="s">VOOOOOM</span><span class="sh">'</span><span class="p">,</span> <span class="n">voltage</span><span class="o">=</span><span class="mi">1000000</span><span class="p">)</span>             <span class="c1"># 2 keyword arguments
</span><span class="nf">parrot</span><span class="p">(</span><span class="sh">'</span><span class="s">a million</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">bereft of life</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">jump</span><span class="sh">'</span><span class="p">)</span>         <span class="c1"># 3 positional arguments
</span><span class="nf">parrot</span><span class="p">(</span><span class="sh">'</span><span class="s">a thousand</span><span class="sh">'</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="sh">'</span><span class="s">pushing up the daisies</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 1 positional, 1 keyword
</span></code></pre></div></div> <p>以下调用函数的方式都无效：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parrot</span><span class="p">()</span>                     <span class="c1"># required argument missing
</span><span class="nf">parrot</span><span class="p">(</span><span class="n">voltage</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="sh">'</span><span class="s">dead</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># non-keyword argument after a keyword argument
</span><span class="nf">parrot</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="n">voltage</span><span class="o">=</span><span class="mi">220</span><span class="p">)</span>     <span class="c1"># duplicate value for the same argument
</span><span class="nf">parrot</span><span class="p">(</span><span class="n">actor</span><span class="o">=</span><span class="sh">'</span><span class="s">John Cleese</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># unknown keyword argument
</span></code></pre></div></div> <p>函数调用时，关键字参数必须跟在位置参数后面。所有传递的关键字参数都必须匹配一个函数接受的参数（比如，actor 不是函数 parrot 的有效参数），关键字参数的顺序并不重要。这也包括必选参数，（比如，parrot(voltage=1000) 也有效）。不能对同一个参数多次赋值，下面就是一个因此限制而失败的例子：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nf">function</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="sh">"</span><span class="s">&lt;stdin&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="nf">function</span><span class="p">()</span> <span class="n">got</span> <span class="n">multiple</span> <span class="n">values</span> <span class="k">for</span> <span class="n">argument</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span>
</code></pre></div></div> <p>最后一个形参为 **name 形式时，接收一个字典（详见 <a href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#typesmapping">映射类型 — dict</a>），该字典包含与函数中已定义形参对应之外的所有关键字参数。**name 形参可以与 *name 形参（下一小节介绍）组合使用（*name 必须在 **name 前面）， *name 形参接收一个 <a href="https://docs.python.org/zh-cn/3.11/tutorial/datastructures.html#tut-tuples">元组</a>，该元组包含形参列表之外的位置参数。例如，可以定义下面这样的函数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cheeseshop</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-- Do you have any</span><span class="sh">"</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="sh">"</span><span class="s">?</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-- I</span><span class="sh">'</span><span class="s">m sorry, we</span><span class="sh">'</span><span class="s">re all out of</span><span class="sh">"</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">arguments</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-</span><span class="sh">"</span> <span class="o">*</span> <span class="mi">40</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="sh">"</span><span class="s">:</span><span class="sh">"</span><span class="p">,</span> <span class="n">keywords</span><span class="p">[</span><span class="n">kw</span><span class="p">])</span>
</code></pre></div></div> <p>该函数可以用如下方式调用：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cheeseshop</span><span class="p">(</span><span class="sh">"</span><span class="s">Limburger</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">It</span><span class="sh">'</span><span class="s">s very runny, sir.</span><span class="sh">"</span><span class="p">,</span>
           <span class="sh">"</span><span class="s">It</span><span class="sh">'</span><span class="s">s really very, VERY runny, sir.</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">shopkeeper</span><span class="o">=</span><span class="sh">"</span><span class="s">Michael Palin</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">client</span><span class="o">=</span><span class="sh">"</span><span class="s">John Cleese</span><span class="sh">"</span><span class="p">,</span>
           <span class="n">sketch</span><span class="o">=</span><span class="sh">"</span><span class="s">Cheese Shop Sketch</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>输出结果如下：</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
shopkeeper : Michael Palin
client : John Cleese
sketch : Cheese Shop Sketch
</code></pre></div></div> <p>注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。</p> <h4 id="特殊参数">特殊参数</h4> <p>默认情况下，参数可以按位置或显式关键字传递给 Python 函数。为了让代码易读、高效，最好限制参数的传递方式，这样，开发者只需查看函数定义，即可确定参数项是仅按位置、按位置或关键字，还是仅按关键字传递。</p> <p>函数定义如下：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">pos_or_kwd</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kwd1</span><span class="p">,</span> <span class="n">kwd2</span><span class="p">):</span>
      <span class="o">-----------</span>    <span class="o">----------</span>     <span class="o">----------</span>
        <span class="o">|</span>             <span class="o">|</span>                  <span class="o">|</span>
        <span class="o">|</span>        <span class="n">Positional</span> <span class="ow">or</span> <span class="n">keyword</span>   <span class="o">|</span>
        <span class="o">|</span>                                <span class="o">-</span> <span class="n">Keyword</span> <span class="n">only</span>
         <span class="o">--</span> <span class="n">Positional</span> <span class="n">only</span>
</code></pre></div></div> <p>/ 和 * 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。关键字形参也叫作命名形参。</p> <p>函数定义中未使用 / 和 * 时，参数可以按位置或关键字传递给函数。</p> <p>此处再介绍一些细节，特定形参可以标记为 仅限位置。仅限位置 时，形参的顺序很重要，且这些形参不能用关键字传递。仅限位置形参应放在 / （正斜杠）前。/ 用于在逻辑上分割仅限位置形参与其它形参。如果函数定义中没有 /，则表示没有仅限位置形参。</p> <p>/ 后可以是 位置或关键字 或 仅限关键字 形参。</p> <p>把形参标记为 仅限关键字，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 仅限关键字 形参前添加 *。</p> <p>请看下面的函数定义示例，注意 / 和 * 标记：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">standard_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pos_only_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">kwd_only_arg</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">combined_example</span><span class="p">(</span><span class="n">pos_only</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">standard</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kwd_only</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">pos_only</span><span class="p">,</span> <span class="n">standard</span><span class="p">,</span> <span class="n">kwd_only</span><span class="p">)</span>
</code></pre></div></div> <p>第一个函数定义 standard_arg 是最常见的形式，对调用方式没有任何限制，可以按位置也可以按关键字传递参数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">standard_arg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>

<span class="nf">standard_arg</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div></div> <p>第二个函数 pos_only_arg 的函数定义中有 /，仅限使用位置形参：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">pos_only_arg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>

<span class="nf">pos_only_arg</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="sh">"</span><span class="s">&lt;stdin&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="nf">pos_only_arg</span><span class="p">()</span> <span class="n">got</span> <span class="n">some</span> <span class="n">positional</span><span class="o">-</span><span class="n">only</span> <span class="n">arguments</span> <span class="n">passed</span> <span class="k">as</span> <span class="n">keyword</span> <span class="n">arguments</span><span class="p">:</span> <span class="sh">'</span><span class="s">arg</span><span class="sh">'</span>
</code></pre></div></div> <p>第三个函数 kwd_only_args 的函数定义通过 * 表明仅限关键字参数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">kwd_only_arg</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="sh">"</span><span class="s">&lt;stdin&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="nf">kwd_only_arg</span><span class="p">()</span> <span class="n">takes</span> <span class="mi">0</span> <span class="n">positional</span> <span class="n">arguments</span> <span class="n">but</span> <span class="mi">1</span> <span class="n">was</span> <span class="n">given</span>

<span class="nf">kwd_only_arg</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div></div> <p>最后一个函数在同一个函数定义中，使用了全部三种调用惯例：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">combined_example</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="sh">"</span><span class="s">&lt;stdin&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="nf">combined_example</span><span class="p">()</span> <span class="n">takes</span> <span class="mi">2</span> <span class="n">positional</span> <span class="n">arguments</span> <span class="n">but</span> <span class="mi">3</span> <span class="n">were</span> <span class="n">given</span>

<span class="nf">combined_example</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kwd_only</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>

<span class="nf">combined_example</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">standard</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">kwd_only</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>

<span class="nf">combined_example</span><span class="p">(</span><span class="n">pos_only</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">standard</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">kwd_only</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="sh">"</span><span class="s">&lt;stdin&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="nf">combined_example</span><span class="p">()</span> <span class="n">got</span> <span class="n">some</span> <span class="n">positional</span><span class="o">-</span><span class="n">only</span> <span class="n">arguments</span> <span class="n">passed</span> <span class="k">as</span> <span class="n">keyword</span> <span class="n">arguments</span><span class="p">:</span> <span class="sh">'</span><span class="s">pos_only</span><span class="sh">'</span>
</code></pre></div></div> <p>下面的函数定义中，kwds 把 name 当作键，因此，可能与位置参数 name 产生潜在冲突：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="k">return</span> <span class="sh">'</span><span class="s">name</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">kwds</span>
</code></pre></div></div> <p>调用该函数不可能返回 True，因为关键字 ‘name’ 总与第一个形参绑定。例如：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="nc">Traceback </span><span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="sh">"</span><span class="s">&lt;stdin&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="nf">foo</span><span class="p">()</span> <span class="n">got</span> <span class="n">multiple</span> <span class="n">values</span> <span class="k">for</span> <span class="n">argument</span> <span class="sh">'</span><span class="s">name</span><span class="sh">'</span>
</code></pre></div></div> <p>加上 / （仅限位置参数）后，就可以了。此时，函数定义把 name 当作位置参数，’name’ 也可以作为关键字参数的键：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>

    <span class="k">return</span> <span class="sh">'</span><span class="s">name</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">kwds</span>

<span class="nf">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="bp">True</span>
</code></pre></div></div> <p>换句话说，仅限位置形参的名称可以在 **kwds 中使用，而不产生歧义。</p> <p>以下用例决定哪些形参可以用于函数定义：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">pos_or_kwd</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kwd1</span><span class="p">,</span> <span class="n">kwd2</span><span class="p">):</span>
</code></pre></div></div> <p>说明：</p> <ul> <li>使用仅限位置形参，可以让用户无法使用形参名。形参名没有实际意义时，强制调用函数的实参顺序时，或同时接收位置形参和关键字时，这种方式很有用。</li> <li>当形参名有实际意义，且显式名称可以让函数定义更易理解时，阻止用户依赖传递实参的位置时，才使用关键字。</li> <li>对于 API，使用仅限位置形参，可以防止未来修改形参名时造成破坏性的 API 变动。</li> </ul> <h4 id="任意实参列表">任意实参列表</h4> <p>调用函数时，使用任意数量的实参是最少见的选项。这些实参包含在元组中。在可变数量的实参之前，可能有若干个普通参数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write_multiple_items</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">separator</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">file</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">separator</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
</code></pre></div></div> <p>variadic 参数用于采集传递给函数的所有剩余参数，因此，它们通常在形参列表的末尾。*args 形参后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sep</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

<span class="nf">concat</span><span class="p">(</span><span class="sh">"</span><span class="s">earth</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">mars</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">venus</span><span class="sh">"</span><span class="p">)</span>
<span class="sh">'</span><span class="s">earth/mars/venus</span><span class="sh">'</span>

<span class="nf">concat</span><span class="p">(</span><span class="sh">"</span><span class="s">earth</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">mars</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">venus</span><span class="sh">"</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sh">"</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
<span class="sh">'</span><span class="s">earth.mars.venus</span><span class="sh">'</span>
</code></pre></div></div> <h4 id="解包实参列表">解包实参列表</h4> <p>函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。例如，内置的 range() 函数要求独立的 start 和 stop 实参。如果这些参数不是独立的，则要在调用函数时，用 * 操作符把实参从列表或元组解包出来：</p> <p>函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。例如，内置的 range() 函数要求独立的 start 和 stop 实参。如果这些参数不是独立的，则要在调用函数时，用 * 操作符把实参从列表或元组解包出来：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>            <span class="c1"># normal call with separate arguments
</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>            <span class="c1"># call with arguments unpacked from a list
</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</code></pre></div></div> <p>同样，字典可以用 ** 操作符传递关键字参数：</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parrot</span><span class="p">(</span><span class="n">voltage</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="sh">'</span><span class="s">a stiff</span><span class="sh">'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="sh">'</span><span class="s">voom</span><span class="sh">'</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">-- This parrot wouldn</span><span class="sh">'</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">if you put</span><span class="sh">"</span><span class="p">,</span> <span class="n">voltage</span><span class="p">,</span> <span class="sh">"</span><span class="s">volts through it.</span><span class="sh">"</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">E</span><span class="sh">'</span><span class="s">s</span><span class="sh">"</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="sh">"</span><span class="s">!</span><span class="sh">"</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">voltage</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">four million</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">state</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">bleedin</span><span class="sh">'</span><span class="s"> demised</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">action</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">VOOM</span><span class="sh">"</span><span class="p">}</span>

<span class="nf">parrot</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
<span class="o">--</span> <span class="n">This</span> <span class="n">parrot</span> <span class="n">wouldn</span><span class="sh">'</span><span class="s">t VOOM if you put four million volts through it. E</span><span class="sh">'</span><span class="n">s</span> <span class="n">bleedin</span><span class="sh">'</span><span class="s"> demised !
</span></code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[Python 简介]]></summary></entry><entry><title type="html">LaTeX 不太简短的介绍</title><link href="https://jkfx.github.io/blog/2025/LaTeX%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D/" rel="alternate" type="text/html" title="LaTeX 不太简短的介绍"/><published>2025-03-02T11:13:00+00:00</published><updated>2025-03-02T11:13:00+00:00</updated><id>https://jkfx.github.io/blog/2025/LaTeX%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="https://jkfx.github.io/blog/2025/LaTeX%E4%B8%8D%E5%A4%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D/"><![CDATA[<h2 id="latex-的基本概念">LaTeX 的基本概念</h2> <h3 id="概述">概述</h3> <p>Tex 是高德纳为排版文字和数学公式而开发的软件。</p> <p>LaTeX 是一种使用 Tex 程序作为排版引擎的格式，可以粗略地将它理解成是对 Tex 的一层封装。</p> <p>LaTeX 最初的设计目的是<strong>分离内容与格式</strong>，以便作者能够<strong>专注于内容创作而非排版设计</strong>，并能以此得到高质量排版的作品。</p> <h3 id="latex-命令和代码结构">LaTeX 命令和代码结构</h3> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>ctexart<span class="p">}</span>
<span class="nt">\begin{documeng}</span>
“你好，世界！”来自 <span class="k">\LaTeX</span><span class="p">{}</span> 的问候。
<span class="nt">\end{document}</span>
</code></pre></div></div> <p>字母形式的 LaTeX 命令忽略其后的所有连续空格。如果要人为引入空格，需要在命令后面加一对花括号阻止其忽略空格：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\TeX</span> 会忽略空格。
<span class="k">\TeX</span><span class="p">{}</span> 不会忽略空格。
</code></pre></div></div> <p>LaTeX 还包括<strong>环境</strong>，用以令一些效果在局部生效，或是生成特殊的文档元素。LaTeX 环境的用法为一对命令 <code class="language-plaintext highlighter-rouge">\begin</code> 和 <code class="language-plaintext highlighter-rouge">\end</code> ，部分环境允许嵌套使用：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{&lt;enviroment name&gt;}</span>[&lt;optional arguments&gt;]<span class="p">{</span>&lt;mandatory arguments&gt;<span class="p">}</span>
...
<span class="nt">\end{&lt;enviroment name&gt;}</span>
</code></pre></div></div> <p>有些命令（如 <code class="language-plaintext highlighter-rouge">\bfseries</code> ）会对其后所有内容产生作用。若要限制其作用范围，则需要使用<strong>分组</strong>。LaTeX 使用一对花括号 <code class="language-plaintext highlighter-rouge">{</code> 和 <code class="language-plaintext highlighter-rouge">}</code> 作为分组，在分组中使用的命令被限制在分组内，不会影响到分组外的内容（<em>个别命令在分组内仍然会产生全局作用</em>）。上文提到的 LaTeX 环境隐含了一个分组，在环境中的命令被包裹在分组内。</p> <p>LaTeX 的源代码结构：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>...<span class="p">}</span> <span class="c">% ... 为某文档</span>
<span class="c">% 导言区</span>
<span class="nt">\begin{document}</span>
<span class="c">% 正文内容</span>
<span class="nt">\end{document}</span>
<span class="c">% 此后内容会被忽略</span>
</code></pre></div></div> <h3 id="latex-宏包和文档类">LaTeX 宏包和文档类</h3> <p><strong>文档类</strong>规定了 LaTeX 源代码所要生成的文档的性质——普通文章、书籍、演示文稿、个人简历等等。LaTeX 源代码的开头须用 <code class="language-plaintext highlighter-rouge">\documentclass</code> 指定文档类:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="na">[&lt;options&gt;]</span><span class="p">{</span>&lt;class-name&gt;<span class="p">}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">⟨class-name⟩</code> 为文档类的名称，如 LaTeX 提供的 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">report</code>、<code class="language-plaintext highlighter-rouge">book</code>，在其基础上派 生的一些文档类，如支持中文排版的 <code class="language-plaintext highlighter-rouge">ctexart</code>、<code class="language-plaintext highlighter-rouge">ctexrep</code>、<code class="language-plaintext highlighter-rouge">ctexbook</code>，或者有其它功能的一些文档类， 如 <code class="language-plaintext highlighter-rouge">moderncv</code>、`beamer 等。其中前三个习惯上称为“标准文档类”。</p> <p>可选参数 <code class="language-plaintext highlighter-rouge">⟨options⟩</code> 为文档类指定选项，以全局地规定一些排版的参数，如字号、纸张大小、 单双面等等。比如调用 article 文档类排版文章，指定纸张为 A4 大小，基本字号为 11pt，双面 排版:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="na">[11pt,twoside,a4paper]</span><span class="p">{</span>article<span class="p">}</span>
</code></pre></div></div> <p>LaTeX 的三个标准文档类可指定的选项包括:</p> <p><code class="language-plaintext highlighter-rouge">10pt, 11pt, 12pt</code> 指定文档的基本字号。默认为 10pt。<br/> <code class="language-plaintext highlighter-rouge">a4paper, letterpaper, ...</code> 指定纸张大小，默认为美式信纸letterpaper(8.5in×11in，大 约相当于 21.6 cm × 28.0 cm)。可指定选项还包括 a5paper，b5paper，executivepaper 和 legalpaper。有关纸张大小的更多细节。<br/> <code class="language-plaintext highlighter-rouge">twoside, oneside</code> 指定单面/双面排版。双面排版时，奇偶页的页眉页脚、页边距不同。article 和 report 默认为 oneside，book 默认为 twoside。<br/> <code class="language-plaintext highlighter-rouge">onecolumn, twocolumn</code> 指定单栏/双栏排版。默认为 onecolumn。<br/> <code class="language-plaintext highlighter-rouge">openright, openany</code> 指定新的一章 \chapter 是在奇数页(右侧)开始，还是直接紧跟着上一页开始。report 默认为 openany，book 默认为 openright。对 article 无效。<br/> <code class="language-plaintext highlighter-rouge">landscape</code> 指定横向排版。默认为纵向。<br/> <code class="language-plaintext highlighter-rouge">titlepage, notitlepage</code> 指定标题命令 \maketitle 是否生成单独的标题页。article 默认为 notitlepage，report 和 book 默认为 titlepage。<br/> <code class="language-plaintext highlighter-rouge">fleqn</code> 令行间公式左对齐。默认为居中对齐。<br/> <code class="language-plaintext highlighter-rouge">leqno</code> 将公式编号放在左边。默认为右边。<br/> <code class="language-plaintext highlighter-rouge">draft, final</code> 指定草稿/终稿模式。草稿模式下，断行不良(溢出)的地方会在行尾添加一个 黑色方块;插图、超链接等功能也会受这一组选项影响，具体见后文。默认为 final。</p> <p>在使用 LaTeX 时，时常需要依赖一些扩展来增强或补充 LaTeX 的功能，比如排版复杂的表格、插入图片、增加颜色甚至超链接等等。这些扩展称为<strong>宏包</strong>。调用宏包的方法非常类似调用文档类的方法:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\usepackage</span><span class="na">[⟨options⟩]</span><span class="p">{</span>⟨package-name⟩<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">\usepackage</code> 可以一次性调用多个宏包，在 <code class="language-plaintext highlighter-rouge">⟨package-name⟩</code> 中用逗号隔开。这种用法一般 不要指定选项 :</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">% 一次性调用三个排版表格常用的宏包</span>
<span class="k">\usepackage</span><span class="p">{</span>tabularx, makecell, multirow<span class="p">}</span>
</code></pre></div></div> <p>宏包(包括前面所说的文档类)可能定义了许多命令和环境，或者修改了 LaTeX 已有的命令和环境。它们的用法说明记在相应宏包和文档类的帮助文档。在 Windows 命令提示符或者 Linux 终端下输入命令可查阅相应文档:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>texdoc ⟨pkg-name⟩
</code></pre></div></div> <h3 id="文件的组织方式">文件的组织方式</h3> <p>当编写长篇文档时，例如当编写书籍、毕业论文时，单个源文件会使修改、校对变得十分困难。将源文件分割成若干个文件，例如将每章内容单独写在一个文件中，会大大简化修改和校对的工作。</p> <p>LaTeX 提供了命令 <code class="language-plaintext highlighter-rouge">\include</code> 用来在源代码里插入文件:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\include</span><span class="p">{</span>⟨filename⟩<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">⟨filename⟩</code> 为文件名(不带 <code class="language-plaintext highlighter-rouge">.tex</code> 扩展名)，如果和要编译的主文件不在一个目录中，则要加上相对或绝对路径，例如:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\include</span><span class="p">{</span>chapters/file<span class="p">}</span> <span class="c">% 相对路径</span>
<span class="k">\include</span><span class="p">{</span>/home/Bob/file<span class="p">}</span> <span class="c">% *nix(包含 Linux、macOS)绝对路径 \include{D:/file} % Windows 绝对路径，用正斜线</span>
</code></pre></div></div> <p>值得注意的是 <code class="language-plaintext highlighter-rouge">\include</code> 在读入 <code class="language-plaintext highlighter-rouge">⟨filename⟩</code> 之前会另起一页。有的时候我们并不需要这样， 而是用 <code class="language-plaintext highlighter-rouge">\input</code> 命令，它纯粹是把文件里的内容插入:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\input</span><span class="p">{</span>⟨filename⟩<span class="p">}</span>
</code></pre></div></div> <p>当导言区内容较多时，常常将其单独放置在一个 <code class="language-plaintext highlighter-rouge">.tex</code> 文件中，再用 <code class="language-plaintext highlighter-rouge">\input</code> 命令插入。复杂的图、表、代码等也会用类似的手段处理。</p> <p>LaTeX 还提供了一个 <code class="language-plaintext highlighter-rouge">\includeonly</code> 命令来组织文件，用于<strong>导言区</strong>，指定只载入某些文件。 导言区使用了 <code class="language-plaintext highlighter-rouge">\includeonly</code> 后，正文中不在其列表范围的 <code class="language-plaintext highlighter-rouge">\include</code> 命令不会起效:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\includeonly</span><span class="p">{</span>⟨filename1⟩,⟨filename2⟩,...<span class="p">}</span>
</code></pre></div></div> <p>需要注意的是，使用 <code class="language-plaintext highlighter-rouge">\include</code> 和 <code class="language-plaintext highlighter-rouge">\input</code> 命令载入的文件名最好不要加空格和特殊字符， 也尽量避免使用中文名，否则很可能会出错。</p> <p>最后介绍一个实用的工具宏包 <code class="language-plaintext highlighter-rouge">syntonly</code>。加载这个宏包后，在导言区使用 <code class="language-plaintext highlighter-rouge">\syntaxonly</code> 命令，可令 LaTeX 编译后不生成 DVI 或者 PDF 文档，只排查错误，编译速度会快不少:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\usepackage</span><span class="p">{</span>syntonly<span class="p">}</span>
<span class="k">\syntaxonly</span>
</code></pre></div></div> <p>如果想生成文档，则用 <code class="language-plaintext highlighter-rouge">%</code> 注释掉 <code class="language-plaintext highlighter-rouge">\syntaxonly</code> 命令即可。</p> <h2 id="用-latex-排版文字">用 LaTeX 排版文字</h2> <p>随着 LaTeX 和底层 TEX 引擎的发展， 旧方式(CCT、CJK 等)日渐退出舞台，xelatex 和 lualatex 编译命令配合 ctex 宏包/文档类的方式成为当前的主流中文排版支持方式。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>ctexart<span class="p">}</span>
<span class="nt">\begin{document}</span>
在<span class="k">\LaTeX</span><span class="p">{}</span>中排版中文。 汉字和English单词混排，通常不需要在中英文之间添加额外的空格。 当然，为了代码的可读性，加上汉字和 English 之间的空格也无妨。 汉字换行时不会引入多余的空格。
<span class="nt">\end{document}</span>
</code></pre></div></div> <p>注意源代码须保存为 UTF-8 编码，并使用 xelatex 或 lualatex 命令编译。虽然 ctex 宏包和文档类保留了对 GBK 编码以及 latex 和 pdflatex 编译命令的兼容，但并不推荐这样做。</p> <h3 id="latex-中的字符">LaTeX 中的字符</h3> <p>LaTeX 源代码中，空格键和 Tab 键输入的空白字符视为“空格”。连续的若干个空白字符视为一个空格。一行开头的空格忽略不计。<br/> 行末的换行符视为一个空格;但连续两个换行符，也就是空行，会将文字分段。多个空行被视为一个空行。也可以在行末使用 <code class="language-plaintext highlighter-rouge">\par</code> 命令分段。</p> <p>LaTeX 用 <code class="language-plaintext highlighter-rouge">%</code> 字符作为注释。在这个字符之后直到行末，所有的字符都被忽略，行末的换行符也不引入空格。</p> <p>以下字符在 LaTeX 里有特殊用途，如 <code class="language-plaintext highlighter-rouge">%</code> 表示注释，<code class="language-plaintext highlighter-rouge">$</code>、<code class="language-plaintext highlighter-rouge">^</code>、<code class="language-plaintext highlighter-rouge">_</code> 等用于排版数学公式，<code class="language-plaintext highlighter-rouge">&amp;</code> 用于排版表格，等等。直接输入这些字符得不到对应的符号，还往往会出错。如果想要输入以上符号，需要使用以下带反斜线的形式输入，类似编程语言里的“转义”符号:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\#</span> <span class="k">\$</span> <span class="k">\%</span> <span class="k">\&amp;</span> <span class="k">\{</span> <span class="k">\}</span> <span class="k">\_</span>
<span class="k">\^</span><span class="p">{}</span> <span class="k">\~</span><span class="p">{}</span> <span class="k">\textbackslash</span>
</code></pre></div></div> <p>这些“转义”符号事实上是一些 LaTeX 命令。其中 <code class="language-plaintext highlighter-rouge">\^</code> 和 <code class="language-plaintext highlighter-rouge">\~</code> 两个命令需要一个参数，加一对花括号的写法相当于提供了空的参数，否则它们可能会将后面的字符作为参数，形成重音效果。<code class="language-plaintext highlighter-rouge">\\</code> 被直接定义成了手动换行的命令，输入反斜线就需要用 <code class="language-plaintext highlighter-rouge">\textbackslash</code>。</p> <p>西文排版中经常会出现连字(ligatures)，常见的有 <code class="language-plaintext highlighter-rouge">ff</code>/<code class="language-plaintext highlighter-rouge">fi</code>/<code class="language-plaintext highlighter-rouge">fl</code>/<code class="language-plaintext highlighter-rouge">ffi</code>/<code class="language-plaintext highlighter-rouge">ffl</code>。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It's difficult to find <span class="k">\ldots\\</span>
It's dif<span class="p">{}</span>f<span class="p">{}</span>icult to f<span class="p">{}</span>ind <span class="k">\ldots</span>
</code></pre></div></div> <p>LaTeX 中单引号 ‘ 和 ’ 分别用 ` 和 <code class="language-plaintext highlighter-rouge">'</code> 输入;双引号 “ 和 ” 分别用 `` 和 <code class="language-plaintext highlighter-rouge">''</code> 输入(<code class="language-plaintext highlighter-rouge">"</code> 可以输入后双引号，但没有直接输入前双引号的字符，习惯上用 <code class="language-plaintext highlighter-rouge">''</code> 输入以和 `` 更好地对应)。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>``Please press the `x' key.''
</code></pre></div></div> <p>LaTeX 中有三种长度的“横线”可用:连字号(hyphen)、短破折号(en-dash)和长破折号 (em-dash)。它们分别有不同的用途:连字号用来组成复合词;短破折号用来连接数字表示范围;长破折号用来连接单词，语义上类似中文的破折号。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>daughter-in-law, X-rated<span class="k">\\</span>
pages 13--67<span class="k">\\</span>
yes---or no?
</code></pre></div></div> <p>LaTeX 提供了 <code class="language-plaintext highlighter-rouge">\ldots</code> 命令表示省略号，相对于直接输入三个点的方式更为合理。<code class="language-plaintext highlighter-rouge">\dots</code> 与 <code class="language-plaintext highlighter-rouge">\ldots</code> 命令等效。</p> <h3 id="断行和断页">断行和断页</h3> <p>在西文排版实践中，断行的位置优先选取在两个单词之间，也就是在源代码中输入的“空格” 。“空格”本身通常生成一个间距，它会根据行宽和上下文自动调整，文字密一些的地方， 单词间距就略窄，反之略宽。</p> <p>文字在单词间的“空格”处断行时，“空格”生成的间距随之舍去。我们可以使用字符 <code class="language-plaintext highlighter-rouge">~</code> 输 入一个不会断行的空格(高德纳称之为 tie，“带子”)，通常用在英文人名、图表名称等上下文环境:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Fig.~2a <span class="k">\\</span>
Donald~E.~Knuth
</code></pre></div></div> <p>如果我们确实需要手动断行，可使用如下命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\\</span><span class="na">[⟨length⟩]</span>
<span class="k">\\*</span><span class="na">[⟨length⟩]</span>
<span class="k">\newline</span>
</code></pre></div></div> <p>它们有两点区别:一是 <code class="language-plaintext highlighter-rouge">\\</code> 可以带可选参数 <code class="language-plaintext highlighter-rouge">⟨length⟩</code>，用于在断行处向下增加垂直间距，而 <code class="language-plaintext highlighter-rouge">\newline</code> 不带可选参数;二是 <code class="language-plaintext highlighter-rouge">\\</code> 也在表格、公式等地方用于换行，而 <code class="language-plaintext highlighter-rouge">\newline</code> 只用于文本段落中。带星号的 <code class="language-plaintext highlighter-rouge">\\</code> 表示禁止在断行处分页。</p> <p>另外需要注意的是，使用 <code class="language-plaintext highlighter-rouge">\\</code> 断行命令 不会令内容另起一段，而是在段落中直接开始新的一行。</p> <p>断页的命令有两个：</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\newpage</span>
<span class="k">\clearpage</span>
</code></pre></div></div> <p>通常情况下两个命令都起到另起一页的作用，区别在于:第一，在双栏排版模式中 <code class="language-plaintext highlighter-rouge">\newpage</code> 起到另起一栏的作用，<code class="language-plaintext highlighter-rouge">\clearpage</code> 则能够另起一页;第二，在涉及浮动体的排版上行为不同。</p> <h2 id="文档元素">文档元素</h2> <h3 id="章节和目录">章节和目录</h3> <p>一篇文档通过不同的命令分割为章、节、小节。三个标准文档类 <code class="language-plaintext highlighter-rouge">article</code>、<code class="language-plaintext highlighter-rouge">report</code> 和 <code class="language-plaintext highlighter-rouge">book</code>提供了划分章节的命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\chapter</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\section</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\subsection</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\subsubsection</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\paragraph</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
<span class="k">\subparagraph</span><span class="p">{</span>⟨title⟩<span class="p">}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">\chapter</code> 只在 report 和 book 文档类有定义。这些命令生成章节标题，并能够自动编号。 除此之外 LaTeX 还提供了 <code class="language-plaintext highlighter-rouge">\part</code> 命令，用来将整个文档分割为大的分块，但不影响 \chapter 或 \section 等的编号。</p> <p>上述命令除了生成带编号的标题之外，还向目录中添加条目，并影响页眉页脚的内容。每个命令有两种变体:</p> <ul> <li>带可选参数的变体:<code class="language-plaintext highlighter-rouge">\section[⟨short title⟩]{⟨title⟩}</code><br/> 标题使用 <code class="language-plaintext highlighter-rouge">⟨title⟩</code> 参数，在目录和页眉页脚中使用 <code class="language-plaintext highlighter-rouge">⟨short title⟩</code> 参数；</li> <li>带星号的变体:<code class="language-plaintext highlighter-rouge">\section*{⟨title⟩}</code><br/> 标题不带编号，也不生成目录项和页眉页脚。</li> </ul> <p>较低层次如 <code class="language-plaintext highlighter-rouge">\paragraph</code> 和 <code class="language-plaintext highlighter-rouge">\subparagraph</code> 即使不用带星号的变体，生成的标题默认也不带编号，事实上，除 <code class="language-plaintext highlighter-rouge">\part</code> 外:</p> <ul> <li><code class="language-plaintext highlighter-rouge">article</code> 文档类带编号的层级为 <code class="language-plaintext highlighter-rouge">\section</code>、<code class="language-plaintext highlighter-rouge">\subsection</code>、<code class="language-plaintext highlighter-rouge">\subsubsection</code> 三级；</li> <li><code class="language-plaintext highlighter-rouge">report</code> 和 <code class="language-plaintext highlighter-rouge">book</code> 文档类带编号的层级为 <code class="language-plaintext highlighter-rouge">\chapter</code>、<code class="language-plaintext highlighter-rouge">\section</code>、<code class="language-plaintext highlighter-rouge">\subsection</code> 三级。</li> </ul> <p>LaTeX 及标准文档类并未提供为 \section 等章节命令定制格式的功能，这一功能由 <code class="language-plaintext highlighter-rouge">titlesec</code>宏包提供。</p> <h3 id="目录">目录</h3> <p>在 LateX 中生成目录非常容易，只需在合适的地方使用命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\tableofcontents</span>
</code></pre></div></div> <p>这个命令会生成单独的一章(report/book)或一节(article)，标题默认为“Contents”。\tableofcontents 生成的章节默认不写入目录(\section* 或 \chapter*)，可使用 <code class="language-plaintext highlighter-rouge">tocbibind</code> 等宏包修改设置。</p> <p>正确生成目录项，一般需要编译两次源代码。</p> <p>有时我们使用了 \chapter* 或 \section* 这样不生成目录项的章节标题命令，而又想手动生成该章节的目录项，可以在标题命令后面使用:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\addcontentsline</span><span class="p">{</span>toc<span class="p">}{</span>⟨level⟩<span class="p">}{</span>⟨title⟩<span class="p">}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">⟨level⟩</code> 为章节层次 chapter 或 section 等，<code class="language-plaintext highlighter-rouge">⟨title⟩</code> 为出现于目录项的章节标题。</p> <p><code class="language-plaintext highlighter-rouge">titletoc</code>、<code class="language-plaintext highlighter-rouge">tocloft</code> 等宏包提供了具体定制目录项格式的功能。</p> <h3 id="文档结构的划分">文档结构的划分</h3> <p>所有标准文档类都提供了一个 <code class="language-plaintext highlighter-rouge">\appendix</code> 命令将正文和附录分开，使用 <code class="language-plaintext highlighter-rouge">\appendix</code> 后，最高一级章节改为使用拉丁字母编号，从 A 开始。</p> <p>book 文档类还提供了前言、正文、后记结构的划分命令:</p> <p><code class="language-plaintext highlighter-rouge">\frontmatter</code> 前言部分，页码使用小写罗马数字;其后的 \chapter 不编号。</p> <p><code class="language-plaintext highlighter-rouge">\mainmatter</code> 正文部分，页码使用阿拉伯数字，从 1 开始计数;其后的章节编号正常。</p> <p><code class="language-plaintext highlighter-rouge">\backmatter</code> 后记部分，页码格式不变，继续正常计数;其后的 \chapter 不编号。</p> <p>以上三个命令还可和 <code class="language-plaintext highlighter-rouge">\appendix</code> 命令结合，生成有前言、正文、附录、后记四部分的文档。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\documentclass</span><span class="p">{</span>book<span class="p">}</span>

<span class="c">% 导言区，加载宏包和各项设置，包括参考文献、索引等</span>
<span class="k">\usepackage</span><span class="p">{</span>makeidx<span class="p">}</span>    <span class="c">% 调用 makeidx 宏包，用来处理索引 </span>
<span class="k">\makeindex</span>  <span class="c">% 开启索引的收集</span>
<span class="k">\bibliographystyle</span><span class="p">{</span>plain<span class="p">}</span>   <span class="c">% 指定参考文献样式为 plain</span>

<span class="nt">\begin{document}</span>

<span class="k">\frontmatter</span>    <span class="c">% 前言部分</span>
<span class="k">\maketitle</span>  <span class="c">% 标题页</span>
<span class="k">\include</span><span class="p">{</span>preface<span class="p">}</span>   <span class="c">% 前言章节 preface.tex</span>
<span class="k">\tableofcontents</span>

<span class="k">\mainmatter</span> <span class="c">% 正文部分</span>
<span class="k">\include</span><span class="p">{</span>chapter1<span class="p">}</span>  <span class="c">% 第一章 chapter1.tex</span>
<span class="k">\include</span><span class="p">{</span>chapter2<span class="p">}</span>  <span class="c">% 第二章 chapter2.tex</span>
...
<span class="k">\appendix</span>   <span class="c">% 附录</span>
<span class="k">\include</span><span class="p">{</span>appendixA<span class="p">}</span> <span class="c">% 附录 A appendixA.tex</span>
...

<span class="k">\backmatter</span> <span class="c">% 后记部分</span>
<span class="k">\include</span><span class="p">{</span>epilogue<span class="p">}</span>  <span class="c">% 后记 epilogue.tex</span>
<span class="k">\bibliography</span><span class="p">{</span>books<span class="p">}</span>    <span class="c">% 利用 BibTeX 工具从数据库文件 books.bib 生成参考文献</span>
<span class="k">\printindex</span> <span class="c">% 利用 makeindex 工具生成索引</span>

<span class="nt">\end{document}</span>
</code></pre></div></div> <h3 id="标题页">标题页</h3> <p>LaTeX 支持生成简单的标题页。首先需要给定标题和作者等信息:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\title</span><span class="p">{</span>⟨title⟩<span class="p">}</span> <span class="k">\author</span><span class="p">{</span>⟨author ⟩<span class="p">}</span> <span class="k">\date</span><span class="p">{</span>⟨date⟩<span class="p">}</span>
</code></pre></div></div> <p>其中前两个命令是必须的(不用 <code class="language-plaintext highlighter-rouge">\title</code> 会报错;不用 <code class="language-plaintext highlighter-rouge">\author</code> 会警告)，<code class="language-plaintext highlighter-rouge">\date</code> 命令可选。LaTeX 还提供了一个 <code class="language-plaintext highlighter-rouge">\today</code> 命令自动生成当前日期，<code class="language-plaintext highlighter-rouge">\date</code> 默认使用 <code class="language-plaintext highlighter-rouge">\today</code>。在 <code class="language-plaintext highlighter-rouge">\title</code>、<code class="language-plaintext highlighter-rouge">\author</code> 等命令内可以使用 <code class="language-plaintext highlighter-rouge">\thanks</code> 命令生成标题页的脚注，用 <code class="language-plaintext highlighter-rouge">\and</code> 隔开多个人名。在信息给定后，就可以使用 <code class="language-plaintext highlighter-rouge">\maketitle</code> 命令生成一个简单的标题页了。</p> <p>article 文档类的标题默认不单独成页，而 report 和 book 默认单 独成页。可在 <code class="language-plaintext highlighter-rouge">\documentclass</code> 命令调用文档类时指定 <code class="language-plaintext highlighter-rouge">titlepage</code> 或 <code class="language-plaintext highlighter-rouge">notitlepage</code> 选项以修改默认的行为。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\title</span><span class="p">{</span>Test title<span class="p">}</span>
<span class="k">\author</span><span class="p">{</span> Mary<span class="k">\thanks</span><span class="p">{</span>E-mail:*****@***.com<span class="p">}</span>
  <span class="k">\and</span> Ted<span class="k">\thanks</span><span class="p">{</span>Corresponding author<span class="p">}</span>
  <span class="k">\and</span> Louis<span class="p">}</span>
<span class="k">\date</span><span class="p">{</span><span class="k">\today</span><span class="p">}</span>
</code></pre></div></div> <p>LaTeX 标准类还提供了一个简单的 titlepage 环境，生成不带页眉页脚的一页。用户可以 在这个环境中使用各种排版元素自由发挥，生成自定义的标题页以替代 \maketitle 命令。甚至 可以利用 titlepage 环境重新定义 \maketitle:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\renewcommand</span><span class="p">{</span><span class="k">\maketitle</span><span class="p">}{</span>
    <span class="nt">\begin{titlepage}</span>
    ... <span class="c">% 用户自定义命令</span>
    <span class="nt">\end{titlepage}</span>
<span class="p">}</span>
</code></pre></div></div> <p>事实上，为标准文档类指定了 titlepage 选项以后，使用 \maketitle 命令生成的标题页 就是一个 titlepage 环境。</p> <p>以上是 LaTeX 标准文档类的标题页相关命令用法。在各种文档模板中经常有自定义的标题 页，有可能需要除了 \title 和 \author 以外的命令给定信息，用法也可能与标准文档类的不一致(甚至有些模板可能没有定义 titlepage 等环境)。使用文档模板前一定要仔细阅读文档模板的帮助文档。</p> <h3 id="交叉引用">交叉引用</h3> <p>交叉引用是 LaTeX 强大的自动排版功能的体现之一。在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用 <code class="language-plaintext highlighter-rouge">\label</code> 命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\label</span><span class="p">{</span>⟨label-name⟩<span class="p">}</span>
</code></pre></div></div> <p>之后可以在别处使用 <code class="language-plaintext highlighter-rouge">\ref</code> 或 <code class="language-plaintext highlighter-rouge">\pageref</code> 命令，分别生成交叉引用的编号和页码:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\ref</span><span class="p">{</span>⟨label-name⟩<span class="p">}</span> <span class="k">\pageref</span><span class="p">{</span>⟨label-name⟩<span class="p">}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A reference to this subsection
<span class="k">\label</span><span class="p">{</span>sec:this<span class="p">}</span> looks like:

``see section~<span class="k">\ref</span><span class="p">{</span>sec:this<span class="p">}</span> on
page~<span class="k">\pageref</span><span class="p">{</span>sec:this<span class="p">}</span>.''
</code></pre></div></div> <p>为了生成正确的交叉引用，一般也需要多次编译源代码。</p> <p><code class="language-plaintext highlighter-rouge">\label</code> 命令可用于记录各种类型的交叉引用，使用位置分别为:</p> <ul> <li><strong>章节标题</strong> 在章节标题命令 <code class="language-plaintext highlighter-rouge">\section</code> 等之后紧接着使用。</li> <li><strong>行间公式</strong> 单行公式在公式内任意位置使用;多行公式在每一行公式的任意位置使用。 有序列表 在 <code class="language-plaintext highlighter-rouge">enumerate</code> 环境的每个 <code class="language-plaintext highlighter-rouge">\item</code> 命令之后、下一个 <code class="language-plaintext highlighter-rouge">\item</code> 命令之前任意位置使用。 图表标题在图表标题命令 <code class="language-plaintext highlighter-rouge">\caption</code> 之后紧接着使用。</li> <li><strong>定理环境</strong> 在定理环境内部任意位置使用。</li> </ul> <p>在使用不记编号的命令形式(<code class="language-plaintext highlighter-rouge">\section*</code>、<code class="language-plaintext highlighter-rouge">\caption*</code>、带可选参数的 <code class="language-plaintext highlighter-rouge">\item</code> 命令等)时不要使用 <code class="language-plaintext highlighter-rouge">\label</code> 命令，否则生成的引用编号不正确。</p> <h3 id="脚注和边注">脚注和边注</h3> <p>使用 <code class="language-plaintext highlighter-rouge">\footnote</code> 命令可以在页面底部生成一个脚注:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\footnote</span><span class="p">{</span>⟨footnote⟩<span class="p">}</span>
</code></pre></div></div> <p>有些情况下(比如在表格环境、各种盒子内)使用 <code class="language-plaintext highlighter-rouge">\footnote</code> 并不能正确生成脚注。我们可以分两步进行，先使用 <code class="language-plaintext highlighter-rouge">\footnotemark</code> 为脚注计数，再在合适的位置用 <code class="language-plaintext highlighter-rouge">\footnotetext</code> 生成 脚注。比如:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{tabular}</span><span class="p">{</span>l<span class="p">}</span>
<span class="k">\hline</span> “天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。”<span class="k">\footnotemark</span> <span class="k">\\</span> <span class="k">\hline</span>
<span class="nt">\end{tabular}</span>
<span class="k">\footnotetext</span><span class="p">{</span>表格里的名句出自《千字文》。<span class="p">}</span>
</code></pre></div></div> <p>使用 <code class="language-plaintext highlighter-rouge">\marginpar</code> 命令可在边栏位置生成边注:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\marginpar</span><span class="na">[⟨left-margin⟩]</span><span class="p">{</span>⟨right-margin⟩<span class="p">}</span>
</code></pre></div></div> <p>如果只给定了 <code class="language-plaintext highlighter-rouge">⟨right-margin⟩</code>，那么边注在奇偶数页文字相同;如果同时给定了 <code class="language-plaintext highlighter-rouge">⟨left-margin⟩</code>，则 偶数页使用 <code class="language-plaintext highlighter-rouge">⟨left-margin⟩</code> 的文字。</p> <h3 id="列表">列表</h3> <p>LaTeX 提供了基本的有序和无序列表环境 <code class="language-plaintext highlighter-rouge">enumerate</code> 和 <code class="language-plaintext highlighter-rouge">itemize</code> ，两者的用法都很类似，都用 <code class="language-plaintext highlighter-rouge">\item</code> 标明每个列表项。<code class="language-plaintext highlighter-rouge">enumerate</code> 环境会自动对列表项编号。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{enumerate}</span> <span class="k">\item</span> ... <span class="nt">\end{enumerate}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">\item</code> 可带一个可选参数，将有序列表的计数或者无序列表的符号替换成自定义的符号。列表可以嵌套使用，最多嵌套四层。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{enumerate}</span>
  <span class="k">\item</span> An item.
  <span class="nt">\begin{enumerate}</span>
    <span class="k">\item</span> A nested item.<span class="k">\label</span><span class="p">{</span>itref<span class="p">}</span>
    <span class="k">\item</span><span class="na">[*]</span> A starred item.
  <span class="nt">\end{enumerate}</span>
  <span class="k">\item</span> Reference(<span class="k">\ref</span><span class="p">{</span>itref<span class="p">}</span>).
<span class="nt">\end{enumerate}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{itemize}</span>
  <span class="k">\item</span> An item.
  <span class="nt">\begin{itemize}</span>
    <span class="k">\item</span> A nested item.
    <span class="k">\item</span><span class="na">[+]</span> A `plus' item.
    <span class="k">\item</span> Another item.
  <span class="nt">\end{itemize}</span>
  <span class="k">\item</span> Go back to upper level.
<span class="nt">\end{itemize}</span>
</code></pre></div></div> <p>关键字环境 <code class="language-plaintext highlighter-rouge">description</code> 的用法与以上两者类似，不同的是<code class="language-plaintext highlighter-rouge">\item</code> 后的可选参数用来写关键字，以粗体显示，一般是必填的:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{description}</span> 
  <span class="k">\item</span><span class="na">[⟨item title⟩]</span> ... 
<span class="nt">\end{description}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{description}</span>
  <span class="k">\item</span><span class="na">[Enumerate]</span> Numbered list.
  <span class="k">\item</span><span class="na">[Itemize]</span> Non-numbered list.
<span class="nt">\end{description}</span>
</code></pre></div></div> <p>各级无序列表的符号由命令 <code class="language-plaintext highlighter-rouge">\labelitemi</code> 到 <code class="language-plaintext highlighter-rouge">\labelitemiv</code> 定义，可以简单地重新定义它们:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\renewcommand</span><span class="p">{</span><span class="k">\labelitemi</span><span class="p">}{</span><span class="k">\ddag</span><span class="p">}</span>
<span class="k">\renewcommand</span><span class="p">{</span><span class="k">\labelitemii</span><span class="p">}{</span><span class="k">\dag</span><span class="p">}</span>
<span class="nt">\begin{itemize}</span>
  <span class="k">\item</span> First item
  <span class="nt">\begin{itemize}</span>
    <span class="k">\item</span> Subitem
    <span class="k">\item</span> Subitem
  <span class="nt">\end{itemize}</span>
  <span class="k">\item</span> Second item
<span class="nt">\end{itemize}</span>
</code></pre></div></div> <p>有序列表的符号由命令 <code class="language-plaintext highlighter-rouge">\labelenumi</code> 到 <code class="language-plaintext highlighter-rouge">\labelenumiv</code> 定义，重新定义这些命令需要用到计数器相关命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\renewcommand</span><span class="p">{</span><span class="k">\labelenumi</span><span class="p">}</span><span class="c">%</span>
  <span class="p">{</span><span class="k">\Alph</span><span class="p">{</span>enumi<span class="p">}</span>&gt;<span class="p">}</span>
<span class="nt">\begin{enumerate}</span>
  <span class="k">\item</span> First item
  <span class="k">\item</span> Second item
<span class="nt">\end{enumerate}</span>
</code></pre></div></div> <p>默认的列表间距比较宽，LaTeX 本身也未提供方便的定制功能，可用 <code class="language-plaintext highlighter-rouge">enumitem</code> 宏包定制各种列表间距。<code class="language-plaintext highlighter-rouge">enumitem</code> 宏包还提供了对列表标签、引用等的定制。有兴趣的读者可参考其帮助文档。</p> <h3 id="对齐环境">对齐环境</h3> <p><code class="language-plaintext highlighter-rouge">center</code>、<code class="language-plaintext highlighter-rouge">flushleft</code> 和 <code class="language-plaintext highlighter-rouge">flushright</code> 环境分别用于生成居中、左对齐和右对齐的文本环境。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{center}</span> ... <span class="nt">\end{center}</span>
<span class="nt">\begin{flushleft}</span> ... <span class="nt">\end{flushleft}</span>
<span class="nt">\begin{flushright}</span> ... <span class="nt">\end{flushright}</span>
</code></pre></div></div> <p>除此之外，还可以用以下命令直接改变文字的对齐方式:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\centering</span> <span class="k">\raggedright</span> <span class="k">\raggedleft</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\centering</span>
Centered text paragraph.
<span class="k">\raggedright</span>
Left-aligned text paragraph.
<span class="k">\raggedleft</span>
Right-aligned text paragraph.
</code></pre></div></div> <p>三个命令和对应的环境经常被误用，有直接用所谓 <code class="language-plaintext highlighter-rouge">\flushleft</code> 命令或者 <code class="language-plaintext highlighter-rouge">raggedright</code> 环境的，都是不甚严格的用法(即使它们可能有效)。有一点可以将两者区分开来:<code class="language-plaintext highlighter-rouge">center</code> 等环境会在上下文产生一个额外间距，而 <code class="language-plaintext highlighter-rouge">\centering</code> 等命令不产生，只是改变对齐方式。比如在浮动 体环境 <code class="language-plaintext highlighter-rouge">table</code> 或 <code class="language-plaintext highlighter-rouge">figure</code> 内实现居中对齐，用 <code class="language-plaintext highlighter-rouge">\centering</code> 命令即可，没必要再用 <code class="language-plaintext highlighter-rouge">center</code> 环境。</p> <h3 id="引用环境">引用环境</h3> <p>LaTeX 提供了两种引用的环境:<code class="language-plaintext highlighter-rouge">quote</code> 用于引用较短的文字，首行不缩进;<code class="language-plaintext highlighter-rouge">quotation</code> 用于引用若干段文字，首行缩进。引用环境较一般文字有额外的左右缩进。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Francis Bacon says:
<span class="nt">\begin{quote}</span>
Knowledge is power.
<span class="nt">\end{quote}</span>
</code></pre></div></div> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>《木兰诗》:
<span class="nt">\begin{quotation}</span>
万里赴戎机，关山度若飞。
朔气传金柝，寒光照铁衣。
将军百战死，壮士十年归。

归来见天子，天子坐明堂。
策勋十二转，赏赐百千强。⋯⋯ 
<span class="nt">\end{quotation}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">verse</code> 用于排版诗歌，与 <code class="language-plaintext highlighter-rouge">quotation</code> 恰好相反，<code class="language-plaintext highlighter-rouge">verse</code> 是首行悬挂缩进的。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rabindranath Tagore's short poem:
<span class="nt">\begin{verse}</span>
Beauty is truth's smile
when she beholds her own face in
a perfect mirror.
<span class="nt">\end{verse}</span>
</code></pre></div></div> <h3 id="摘要环境">摘要环境</h3> <p>摘要环境 <code class="language-plaintext highlighter-rouge">abstract</code> 默认只在标准文档类中的 <code class="language-plaintext highlighter-rouge">article</code> 和 <code class="language-plaintext highlighter-rouge">report</code> 文档类可用，一般用于紧跟 <code class="language-plaintext highlighter-rouge">\maketitle</code> 命令之后介绍文档的摘要。如果文档类指定了 <code class="language-plaintext highlighter-rouge">titlepage</code> 选项，则单独成页;反之， 单栏排版时相当于一个居中的小标题加一个 <code class="language-plaintext highlighter-rouge">quotation</code> 环境，双栏排版时相当于 <code class="language-plaintext highlighter-rouge">\section*</code> 定义的一节。</p> <h3 id="代码环境">代码环境</h3> <p>有时我们需要将一段代码原样转义输出，这就要用到代码环境 <code class="language-plaintext highlighter-rouge">verbatim</code>，它以等宽字体排版代码，回车和空格也分别起到换行和空位的作用;带星号的版本更进一步将空格显示成“␣”。</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{verbatim}</span>
#include &lt;iostream&gt;
int main()
<span class="p">{</span>
  std::cout &lt;&lt; "Hello, world!"
            &lt;&lt; std::endl;
return 0; <span class="p">}</span>
<span class="nt">\end{verbatim}</span>

<span class="p">{</span>verbatim*<span class="p">}</span>
for (int i=0; i&lt;4; ++i)
  printf("Number <span class="c">%d\n",i);</span>
<span class="nt">\end{verbatim*}</span>
</code></pre></div></div> <p>要排版简短的代码或关键字，可使用 <code class="language-plaintext highlighter-rouge">\verb</code> 命令:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">\verb</span><span class="kp">⟨</span><span class="sx">delim⟩</span><span class="kp">⟨</span>code⟩⟨delim⟩
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">⟨delim⟩</code> 标明代码的分界位置，前后必须一致，除字母、空格或星号外，可任意选择使得不与代码本身冲突，习惯上使用 <code class="language-plaintext highlighter-rouge">|</code> 符号。</p> <p>同 <code class="language-plaintext highlighter-rouge">verbatim</code> 环境，<code class="language-plaintext highlighter-rouge">\verb</code> 后也可以带一个星号，以显示空格:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">\verb</span><span class="kp">|</span><span class="sx">\LaTeX</span><span class="kp">|</span><span class="k">\\</span>
<span class="nb">\verb</span><span class="kp">+</span><span class="sx">(a || b)</span><span class="kp">+</span> <span class="k">\verb*</span>+(a || b)+
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">\verb</code> 命令对符号的处理比较复杂，一般不能用在其它命令的参数里，否则多半会出错。</p> <p><code class="language-plaintext highlighter-rouge">verbatim</code> 宏包优化了 <code class="language-plaintext highlighter-rouge">verbatim</code> 环境的内部命令，并提供了 <code class="language-plaintext highlighter-rouge">\verbatiminput</code> 命令用来直接 读入文件生成代码环境。<code class="language-plaintext highlighter-rouge">fancyvrb</code> 宏包提供了可定制格式的 <code class="language-plaintext highlighter-rouge">Verbatim</code> 环境;<code class="language-plaintext highlighter-rouge">listings</code> 宏包更进一步，可生成关键字高亮的代码环境，支持各种程序设计语言的语法和关键字。详情请参考各自的帮助文档。</p> <h3 id="表格">表格</h3> <p>排版表格最基本的 <code class="language-plaintext highlighter-rouge">tabular</code> 环境用法为:</p> <div class="language-tex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">\begin{tabular}</span>[&lt;align&gt;]<span class="p">{</span>&lt;column-spec&gt;<span class="p">}</span>
&lt;item1&gt; <span class="p">&amp;</span> &lt;item2&gt; <span class="p">&amp;</span> ... <span class="k">\\</span>
<span class="k">\hline</span>
&lt;item1&gt; <span class="p">&amp;</span> &lt;item2&gt; <span class="p">&amp;</span> ... <span class="k">\\</span>
<span class="nt">\end{tabular}</span>
</code></pre></div></div> <p>其中 <code class="language-plaintext highlighter-rouge">⟨column-spec⟩</code> 是列格式标记，在接下来的内容将仔细介绍;<code class="language-plaintext highlighter-rouge">&amp;</code> 用来分隔单元格;<code class="language-plaintext highlighter-rouge">\\</code> 用来换行;<code class="language-plaintext highlighter-rouge">\hline</code> 用来在行与行之间绘制横线。</p> <p>直接使用 <code class="language-plaintext highlighter-rouge">tabular</code> 环境的话，会<strong>和周围的文字混排</strong>。此时可用一个可选参数 <code class="language-plaintext highlighter-rouge">⟨align⟩</code> 控制垂 直对齐:<code class="language-plaintext highlighter-rouge">t</code> 和 <code class="language-plaintext highlighter-rouge">b</code> 分别表示按表格顶部、底部对齐，其他参数或省略不写(默认)表示居中对齐。</p> <p>但是通常情况下 <code class="language-plaintext highlighter-rouge">tabular</code> 环境很少与文字直接混排，而是会放在 <code class="language-plaintext highlighter-rouge">table</code> 浮动体环境中，并用 <code class="language-plaintext highlighter-rouge">\caption</code> 命令加标题。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[LaTeX 的基本概念]]></summary></entry><entry><title type="html">Ubuntu 22.04 安装 MySQL</title><link href="https://jkfx.github.io/blog/2022/Ubuntu-22.04-%E5%AE%89%E8%A3%85-MySQL/" rel="alternate" type="text/html" title="Ubuntu 22.04 安装 MySQL"/><published>2022-10-27T21:39:00+00:00</published><updated>2022-10-27T21:39:00+00:00</updated><id>https://jkfx.github.io/blog/2022/Ubuntu%2022.04%20%E5%AE%89%E8%A3%85%20MySQL</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/Ubuntu-22.04-%E5%AE%89%E8%A3%85-MySQL/"><![CDATA[<p>本文记录了在 Ubuntu 22.04 下安装 MySQL 8.0 和 5.7 版本的步骤。</p> <h2 id="下载文件">下载文件</h2> <p>在 <a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a> 发行地址中选择 <code class="language-plaintext highlighter-rouge">Linux - Generic</code> 操作系统，选择对应的 MySQL 版本后，下载 MySQL 的压缩包。</p> <p>本文下载的 8.0.30 以及 5.7.39 版本。</p> <h2 id="安装-mysql-57--80">安装 MySQL 5.7 / 8.0</h2> <p>以管理员权限添加 <code class="language-plaintext highlighter-rouge">mysql</code> 的组以及用户。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> groupadd mysql
<span class="nv">$&gt;</span> useradd <span class="nt">-r</span> <span class="nt">-g</span> mysql <span class="nt">-s</span> /bin/false mysql
</code></pre></div></div> <p>之后进入到 <code class="language-plaintext highlighter-rouge">/usr/local</code> 目录中，将下载好的压缩包解压到该目录，并且建立一个符号链接对应到解压缩出的文件目录，之后创建必需文件夹以及给目录授权。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local
<span class="nv">$&gt;</span> <span class="nb">tar </span>xvf /压缩文件目录/mysql-VERSION-OS.tar.xz
<span class="nv">$&gt;</span> <span class="nb">ln</span> <span class="nt">-s</span> mysql-VERSION-OS mysql
<span class="nv">$&gt;</span> <span class="nb">cd </span>mysql
<span class="nv">$&gt;</span> <span class="nb">mkdir </span>mysql-files
<span class="nv">$&gt;</span> <span class="nb">chown </span>mysql:mysql mysql-files
<span class="nv">$&gt;</span> <span class="nb">chmod </span>750 mysql-files
</code></pre></div></div> <blockquote> <p>如果提示权限不够在命令前面加 <code class="language-plaintext highlighter-rouge">sudo</code> 使用管理员账户执行。</p> </blockquote> <p>将 <code class="language-plaintext highlighter-rouge">mysql</code> 目录添加到环境变量中，以便可以在终端中执行 MySQL 执行文件。可以选择添加到 <code class="language-plaintext highlighter-rouge">/etc/profile</code> 系统环境变量的文件中。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/local/mysql/bin
</code></pre></div></div> <p>之后进入到 <code class="language-plaintext highlighter-rouge">/usr/local/mysql</code> 目录中，执行 MySQL 的初始化命令。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local/mysql
<span class="nv">$&gt;</span> bin/mysqld <span class="nt">--initialize</span> <span class="nt">--user</span><span class="o">=</span>mysql
<span class="c"># 或者执行 bin/mysqld --initialize-insecure --user=mysql</span>
<span class="c"># --initialize 表明初始化 MySQL 时给 root 账户设一个随机值组成的初始密码</span>
<span class="c"># --initialize-insecure 表明初始化 MySQL 时给 root 账户设一个空密码</span>
<span class="c"># 如果当前终端执行 mysqld 的账户是 mysql 也可以忽略 --user=mysql</span>
</code></pre></div></div> <p>初始化成功之后进入到 <code class="language-plaintext highlighter-rouge">mysql</code> 环境中，给 <code class="language-plaintext highlighter-rouge">root</code> 账户重新设置一个密码。</p> <p>如果使用 <code class="language-plaintext highlighter-rouge">--initialize</code> 命令，注意终端输出中 <code class="language-plaintext highlighter-rouge">root</code> 的初始随机密码，下面登录使用。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 使用 --initialize</span>
<span class="nv">$&gt;</span> mysql <span class="nt">-u</span> root <span class="nt">-p</span>
<span class="c"># 输入密码登录</span>

<span class="c"># 使用 --initialize-insecure</span>
<span class="nv">$&gt;</span> mysql <span class="nt">-u</span> root <span class="nt">--skip-password</span>
</code></pre></div></div> <blockquote> <p>如果显示无法连接，可能是没启动 MySQL 服务，执行下面语句开启 MySQL 服务。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local/mysql/support-files
<span class="nv">$&gt;</span> ./mysql.server start
</code></pre></div> </div> </blockquote> <p>进入到 MySQL 环境后，执行 SQL 语句修改 <code class="language-plaintext highlighter-rouge">root</code> 账号密码。</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="err">修改</span> <span class="n">root</span> <span class="err">账号密码</span>
<span class="k">ALTER</span> <span class="k">USER</span> <span class="s1">'root'</span><span class="o">@</span><span class="s1">'localhost'</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">'root-password'</span><span class="p">;</span>
</code></pre></div></div> <h2 id="设置-mysql-服务自动运行">设置 MySQL 服务自动运行</h2> <p>进入到 MySQL 的安装目录，复制支持文件到系统启动脚本目录中，并设置默认运行级别。</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$&gt;</span> <span class="nb">cd</span> /usr/local/mysql/support-files
<span class="nv">$&gt;</span> <span class="nb">cp </span>mysql.server /etc/init.d/mysql
<span class="nv">$&gt;</span> <span class="nb">chmod</span> +x /etc/init.d/mysql
<span class="nv">$&gt;</span> update-rc.d mysql defaults
</code></pre></div></div> <p>注销或者重启， MySQL 服务已经自动启动。</p> <blockquote> <p>如果需要在 5.7 和 8.0 版本之间切换，以同样的步骤执行 MySQL 的初始化命令，将 <code class="language-plaintext highlighter-rouge">/usr/local/mysql</code> 这个符号链接替换为对应的版本目录即可。</p> </blockquote>]]></content><author><name></name></author><summary type="html"><![CDATA[本文记录了在 Ubuntu 22.04 下安装 MySQL 8.0 和 5.7 版本的步骤。]]></summary></entry><entry><title type="html">Clean Architecture</title><link href="https://jkfx.github.io/blog/2022/Clean-Architecture/" rel="alternate" type="text/html" title="Clean Architecture"/><published>2022-07-16T19:41:00+00:00</published><updated>2022-07-16T19:41:00+00:00</updated><id>https://jkfx.github.io/blog/2022/Clean%20Architecture</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/Clean-Architecture/"><![CDATA[<blockquote> <p>by Robert C. Martin (Uncle Bob)<br/> 13 August 2012<br/> <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p> </blockquote> <p><img src="https://tva2.sinaimg.cn/large/006VTcCxly1h48ouqtk4uj30lg0frjxl.jpg" alt="image"/></p> <p>在过去的几十年间，我们已经看到了一系列的关于系统架构的想法。其中包括：</p> <ul> <li><a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal Architecture</a> （也叫 <em>Ports and Adapters</em>）在 <a href="http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627">Growing Object Oriented Software</a> 一书中有着描述</li> <li><a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/">Onion Architecture</a></li> <li><a href="http://blog.cleancoders.com/2011-09-30-Screaming-Architecture">Screaming Architecture</a></li> <li><a href="http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/">DCI</a></li> <li><a href="http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350">BCE</a> 在 <em>Object Oriented Software Engineering: A Use-Case Driven Approach</em> 一书</li> </ul> <p>尽管这些架构在细节上都有着不同之处，它们都是非常相似的。它们都有一个目标，那就是 <strong>关注点分离</strong>（<em>the separation of concerns</em>）。它们通过将软件进行分层实现了这一分离。每一个架构都至少有一层是关于业务规则的，并且另一个是关于接口的处理。</p> <p>这些架构都产生了这样的系统：</p> <ol> <li>独立于框架。这些架构都没有依赖于已存在功能丰富的一些库。这使得你可以使用这些框架作为工具，而不是将你的系统塞进到它们的有限的约束中。</li> <li>可测试性。在没有UI 、数据库、Web 服务器以及其它任何外部元素的情况下,业务逻辑可以被测试。</li> <li>独立于 UI。UI 可以被轻易改变，并且无需影响系统中其它部分。例如，Web UI 可以被替换为终端 UI ，无需改变任何业务规则。</li> <li>独立于数据库。你可以使用 Mongo，BigTable，CouchDB或其它数据库换掉 Oracle 或 SQL Server。你的业务逻辑不受限在数据库中。</li> <li>独立于任何外部机构。事实上，你的业务逻辑根本不了解外部世界。</li> </ol> <p>本篇文章顶部的图片是整合这些架构到一个可行的想法的一个尝试。</p> <h2 id="the-dependency-rule">The Dependency Rule</h2> <blockquote> <p>依赖规则</p> </blockquote> <p>同心圆代表了软件的不同范围。通常来讲，你走的越远，软件就变成了更高的层次。外面的圆是机制（<em>mechanisms</em>），内部的圆是政策（<em>policies</em>）。</p> <p>使得架构运作凌驾一切的规则就是 <strong>依赖规则</strong>（<em>The Dependency Rule</em>）。这一规则说明了：源码中的依赖仅可以指向内部。内部的圆中不允许知道关于外部圆中的任何事物。尤其是一些声明在外部圆中的名称决不允许在内部圆中提及。其中包括：函数、类、变量或其它任何命名的软件实体。</p> <p>出于同样的原因，用在外部圆中的数据格式也不应该被用在内部圆中，尤其是当这些格式是被框架在外部圆中生成出来的时候。我们不想在外部圆中的任何事物影响到内部圆。</p> <h3 id="entities">Entities</h3> <blockquote> <p>实体</p> </blockquote> <p>实体封装了企业范围的业务规则。一个实体可以是带有方法的对象，或者也可以是数据结构和函数的集合。无关紧要的是只要实体可以被企业中许多不同的应用使用即可。</p> <p>如果你并没有一个企业，并且只是单纯的想写一个单一的应用，那么这些实体都是应用的业务对象。它们封装了最通用并且高阶的规则。当外部某些事物改变时，它们是最不可能被改变的。例如，你不会期待这些对象被外部页面导航栏或者安全性的改变而受到影响。任何特定的应用的操作性的改变都不会影响到实体层。</p> <h2 id="use-cases">Use Cases</h2> <blockquote> <p>用例</p> </blockquote> <p>软件中这一层包含了特定的应用业务规则。它封装并实现了系统中所有的用例。这些用例协调了进出实体的数据流，并且指导这些实体到使用它们企业范围业务规则用来实现用例的目标。</p> <p>我们并不期待对这一层的改变影响实体。我们也不期待这一层被外部的改变而受到影响，例如数据库、UI或其它任何常见的普遍框架。这一层与此类问题隔离。</p> <p>但是，我们确实期待应用的操作改变将会影响用例层，并且从而因影响这一层中的软件。如果用例层改变的细节，那么在这一层的某些代码将肯定收到影响。</p> <h2 id="interface-adapters">Interface Adapters</h2> <blockquote> <p>接口适配器</p> </blockquote> <p>在这一层的软件是一个适配器（<em>adapters</em>）的集合，适配器用来将数据从最方便用于用例层和实体层的格式，转换到最方便用于某些外部机构例如数据库或Web的格式。例如，正是这一层整个包含了GUI中的MVC架构。Presenters、VIews和Controllers全部属于这层。模型可只是从controllers传入到用例层的数据结构，并且之后从用例层返回到presenters和views。</p> <p>相似地是，在这一层，数据从最方便用于实体层和用例层的形式，被转换到最方便用于任何一个正在使用的持久框架的形式。这一层的圆中的代码不应该知道任何关于数据库的一切事物。如果数据库是一个SQL数据库，那么所有的SQL应该被限制到这一层，并且尤其是必须限制在这一层与数据库交互的部分。</p> <p>在这一层中还有任何其他适配器，用于将数据从某种外部形式（例如外部服务）转换为用例和实体使用的内部形式。</p> <h2 id="frameworks-and-drivers">Frameworks and Drivers</h2> <blockquote> <p>框架和驱动</p> </blockquote> <p>最外层通常是由框架和工具的组成，例如数据库和 Web 框架等等。通常来说，你不需要在这一层编写太多的代码，而是编写与下一圆圈交互的胶水语言。</p> <p>这一层是所有细节（<em>details</em>）的所在。Web 是一个细节。数据库也是一个细节。我们保持这些事物放在外部，它们不会造成任何破坏。</p> <h2 id="only-four-circles">Only Four Circles?</h2> <blockquote> <p>仅有四个圆？</p> </blockquote> <p>No，这些圆圈都是示意图。你也许会发现你需要多于这四个。没有规则说你必须总是有正好这四个圆。但是，<strong>依赖规则</strong>（<em>The Dependency Rule</em>）总是适用。代码中的依赖总是指向内部。随着你往内部的移动，抽象的层次就会增加。最外层的圆是低层次的具体细节。随着你往内部移动，软件变得更抽象，并且封装高阶的政策（<em>policies</em>）。最内层的圆是最具有普遍性。</p> <h2 id="crossing-boundaries">Crossing boundaries</h2> <blockquote> <p>跨越边界</p> </blockquote> <p>图中的右下方是一个我们如何跨越圆圈边界的示例。它显示了Controllers和Presenters与用例层在下一层的交互。注意控制流。它从controller开始，遍历用例层，并且之后在presenter执行结束。也注意代码中的依赖。它们每一个指向用例层的内部。</p> <p>通常我们使用<a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖反转原则</a>解决这一明显的矛盾。例如，在诸如Java的语言中，我们将安排接口和继承关系，以便源代码依赖关系在跨越边界的正确点减少控制流。</p> <p>例如，考虑到用例层需要调用presenter。但是，这个调用必须不能是直接调用，因为将会违反依赖原则：外圈的名字不能被内圈提及。所以我们在内圈中让用例调用一个接口（这里显示为用例输出端口<em>Use Case Output Port</em>），并让外圈中的presenter实现它。</p> <p>相同的技术被用于跨越所有架构中的边界上。我们采用了动态多态性的有点来创建代码依赖，减少控制流，无论控制流走向哪个方向，都以便于我们遵守依赖原则。</p> <h2 id="what-data-crosses-the-boundaries">What data crosses the boundaries</h2> <blockquote> <p>什么数据跨越边界</p> </blockquote> <p>通常来讲，跨越边界的数据仅仅是数据结构。你可以使用基本结构或简单的数据转换（<em>Data Transfer</em>）对象。或者，数据也可以仅仅是函数调用中的参数。或者你可以将它打包到HashMap中，或者构建它成为一个对象。重要的事情是隔离的、简单的数据结构被传进跨越边界。我们不希望作弊并传递Entity或数据库的某一行。我们也不希望数据结构有任何一个类型违反依赖原则。</p> <p>例如，许多数据库框架在查询响应中返回一个便捷的数据格式。我们也许称之为RowStructure。我们不希望传递行结构到内部跨越边界。这会违反依赖原则，因为它将强制一个内部圆去知道某些外部圆中的事物。</p> <p>所以，当我们传递数据跨越边界时，它总是采用最适合内圈的形式。</p> <h2 id="conclusion">Conclusion</h2> <blockquote> <p>总结</p> </blockquote> <p>遵守这些简单的规则并不难，并且将节省你大量的麻烦事。通过将软件分层，并且遵守依赖原则，你讲创建一个本质上可测试的系统，并具有所有暗含的好处。当系统中任何一个外部部分过时的时候，例如数据库或Web框架，你可以以最少的体力替换掉过时的元素。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[by Robert C. Martin (Uncle Bob) 13 August 2012 https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html]]></summary></entry><entry><title type="html">LaTeX Workshop 配置信息</title><link href="https://jkfx.github.io/blog/2022/Ubuntu-22.04-MacOS-Monterey-%E4%B8%BB%E9%A2%98/" rel="alternate" type="text/html" title="LaTeX Workshop 配置信息"/><published>2022-05-28T22:03:00+00:00</published><updated>2022-05-28T22:03:00+00:00</updated><id>https://jkfx.github.io/blog/2022/Ubuntu%2022.04%20MacOS%20Monterey%20%E4%B8%BB%E9%A2%98</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/Ubuntu-22.04-MacOS-Monterey-%E4%B8%BB%E9%A2%98/"><![CDATA[<p>首先更新源以及升级软件：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt upgrade
</code></pre></div></div> <blockquote> <p>也可以更新一下驱动：</p> <p><code class="language-plaintext highlighter-rouge">sudo ubuntu-drivers autoinstall</code></p> </blockquote> <hr/> <p>之后安装 <code class="language-plaintext highlighter-rouge">gnome-tweaks</code> 以及 <code class="language-plaintext highlighter-rouge">gnome-shell-extensions</code> ：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>gnome-tweaks gnome-shell-extensions
</code></pre></div></div> <p>到<em>GNOME Shell Extensions</em>网站安装谷歌浏览器扩展：<a href="https://extensions.gnome.org/">https://extensions.gnome.org/</a> 。</p> <p>接下来安装 <em>User Themes</em> 主题插件： <a href="https://extensions.gnome.org/extension/19/user-themes/">https://extensions.gnome.org/extension/19/user-themes/</a> 。</p> <hr/> <p>克隆 GitHub 上的 <em>WhiteSur-gtk-theme</em> 主题： <a href="https://github.com/vinceliuice/WhiteSur-gtk-theme">https://github.com/vinceliuice/WhiteSur-gtk-theme</a> 到任意你想存放的目录。</p> <p>进入到 <em>WhiteSur-gtk-theme</em> 目录下，找到 <code class="language-plaintext highlighter-rouge">install.sh</code> 以及 <code class="language-plaintext highlighter-rouge">tweaks.sh</code> 脚本文件，执行命令安装主题：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./install.sh <span class="nt">-t</span> all <span class="nt">-N</span> glassy <span class="nt">-s</span> 220
<span class="nb">sudo</span> ./tweaks.sh <span class="nt">-g</span> <span class="nt">-f</span> monterey
</code></pre></div></div> <p>下载并提取 <em>Mkos-Big-Sur</em> 图标包到你的 <strong>home</strong> 下的 <code class="language-plaintext highlighter-rouge">.icons</code> 目录： <a href="https://www.gnome-look.org/p/1400021">https://www.gnome-look.org/p/1400021</a> 。</p> <hr/> <p>找到 Ubuntu 应用程序 优化（<em>tweaks</em>），选择 <em>外观</em> 菜单，在 <em>图标</em> 、 <em>Shell</em> 以及 <em>过时应用程序</em> 中应用 <em>WhiteSur-</em> 主题以及 <em>Mkos-Big-Sur</em> 图标包。</p> <p>在 <em>窗口标题栏</em> 菜单中将 <em>标题栏按钮</em> 放置到 <em>左</em> 侧。</p> <p>在 <em>GNOME Shell Extensions</em> 网站安装 <em>Blur my Shell</em> 插件： <a href="https://extensions.gnome.org/extension/3193/blur-my-shell/">https://extensions.gnome.org/extension/3193/blur-my-shell/</a> 。</p> <p>在 <em>GNOME Shell Extensions</em> 网站安装 <em>Compiz alike magic lamp effect</em> 插件： <a href="https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/">https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/</a> 。</p> <p>在终端中执行命令：</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gsettings <span class="nb">set </span>org.gnome.shell.extensions.dash-to-dock click-action <span class="s1">'minimize'</span>
</code></pre></div></div> <p>找到 Ubuntu 应用程序的 扩展（<em>extensions</em>），找到 <em>Blur my Shell</em> 扩展，点击 <em>设置</em> 按钮，在 <em>Dash</em> 窗口中将 <em>Dash to Dock blur</em> 选项取消勾选。</p> <p>最后，选择一张你喜欢的 MacOS 壁纸，也可以到这个 GitHub 仓库下载： <a href="https://github.com/vinceliuice/WhiteSur-wallpapers">https://github.com/vinceliuice/WhiteSur-wallpapers</a> 。</p> <ul> <li>参考链接： <a href="https://youtu.be/Y6k7THQ3x6U">https://youtu.be/Y6k7THQ3x6U</a></li> </ul> <hr/> <p>常用 Gnome Shell Extensions</p> <ul> <li><a href="https://extensions.gnome.org/extension/1460/vitals/">Vitals</a></li> <li><a href="https://extensions.gnome.org/extension/675/lunar-calendar/">Lunar Calendar 农历</a></li> <li><a href="https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/">Bluetooth Quick Connect</a></li> <li><a href="https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/">Compiz alike magic lamp effect</a></li> <li><a href="https://extensions.gnome.org/extension/3438/jiggle/">Jiggle</a></li> </ul>]]></content><author><name></name></author><summary type="html"><![CDATA[首先更新源以及升级软件：]]></summary></entry><entry><title type="html">CASIA-WebMaskedFace 模拟佩戴口罩人脸数据集</title><link href="https://jkfx.github.io/blog/2022/CASIA-WebMaskedFace-%E6%A8%A1%E6%8B%9F%E4%BD%A9%E6%88%B4%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E6%95%B0%E6%8D%AE%E9%9B%86/" rel="alternate" type="text/html" title="CASIA-WebMaskedFace 模拟佩戴口罩人脸数据集"/><published>2022-04-14T10:55:00+00:00</published><updated>2022-04-14T10:55:00+00:00</updated><id>https://jkfx.github.io/blog/2022/CASIA-WebMaskedFace%20%E6%A8%A1%E6%8B%9F%E4%BD%A9%E6%88%B4%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E6%95%B0%E6%8D%AE%E9%9B%86</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/CASIA-WebMaskedFace-%E6%A8%A1%E6%8B%9F%E4%BD%A9%E6%88%B4%E5%8F%A3%E7%BD%A9%E4%BA%BA%E8%84%B8%E6%95%B0%E6%8D%AE%E9%9B%86/"><![CDATA[<p>Based on CASIA-WebFace Dataset using MaskTheFace tool mask the face images of datasets.</p> <p>基于CASIA-WebFace数据集，使用MaskTheFace工具给数据集中的人脸图像“戴上口罩”。</p> <h2 id="数据集介绍">数据集介绍</h2> <p>此数据集是在源数据集 <a href="https://arxiv.org/pdf/1411.7923v1.pdf">CASIA-Webface</a> 之上，使用 <a href="https://arxiv.org/abs/2008.11104">MaskTheFace</a> 工具对 CASIA-Webface 数据集中的图像进行佩戴口罩，此数据所涉及到的口罩类型有：Surgical（白色医用外科口罩）、Surgical Blue（蓝色医用外科口罩）、N95、KN95以及Cloth（黑色布质口罩）。口罩的分布类型都是均匀分布随机生成的。</p> <p><img src="https://tvax4.sinaimg.cn/large/006VTcCxly1h191411yh2j313w0aujyr.jpg" alt="image"/></p> <p>关于口罩类型以及口罩颜色和材质的类型的更多介绍，可以查看 <a href="https://github.com/aqeelanwar/MaskTheFace">原工具仓库</a> 。</p> <p>CASIA-WebMaskedFace 有 10,575 个实体人物， 494,414 张人脸图像。</p> <blockquote> <p>此数据集是在 CASIA-Webface 数据集原封不动的基础上进行配到口罩的模拟，所以与原数据集有相同的实体和图像数量。</p> </blockquote> <p>武汉大学国家多媒体软件工程技术研究中心在最早做了相关的 <a href="https://arxiv.org/abs/2003.09093">研究</a> ，也提出了当时最大的模拟口罩人脸数据集和一个真实世界的人脸佩戴口罩的数据集。</p> <p><a href="https://arxiv.org/abs/2008.11104">Aqeel Anwar, Arijit Raychowdhury</a> 在之后也提出了一个真实世界佩戴口罩的人脸数据集，并且提出了一个工具，也就是上文提到的 <a href="https://github.com/aqeelanwar/MaskTheFace">MaskTheFace</a> 用来在已有的人脸数据集上进行模拟佩戴口罩。</p> <h3 id="数据示例">数据示例</h3> <p><img src="https://tvax1.sinaimg.cn/large/006VTcCxly1h191m9mhfyj30pf0atwme.jpg" alt="image"/></p> <p><img src="https://tvax4.sinaimg.cn/large/006VTcCxly1h191pig6fmj30pm0al7be.jpg" alt="image"/></p> <p><img src="https://tvax2.sinaimg.cn/large/006VTcCxly1h191ojwfj1j30pd0aswmv.jpg" alt="image"/></p> <p><img src="https://tvax1.sinaimg.cn/large/006VTcCxly1h191qg3bm0j30pe0amwn6.jpg" alt="image"/></p> <h2 id="下载地址">下载地址</h2> <ul class="task-list"> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Kaggle：<a href="https://www.kaggle.com/datasets/geekfx/casia-webmaskedface">https://www.kaggle.com/datasets/geekfx/casia-webmaskedface</a></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked"/>Kaggle (cropped using MTCNN, 160x160)：<a href="https://www.kaggle.com/datasets/geekfx/casia-webmaskedface-cropped">https://www.kaggle.com/datasets/geekfx/casia-webmaskedface-cropped</a></li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>百度网盘</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>Google Drive</li> <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled"/>GitHub</li> </ul>]]></content><author><name></name></author><summary type="html"><![CDATA[Based on CASIA-WebFace Dataset using MaskTheFace tool mask the face images of datasets.]]></summary></entry><entry><title type="html">LaTeX Workshop 配置信息</title><link href="https://jkfx.github.io/blog/2022/LaTeX-Workshop-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/" rel="alternate" type="text/html" title="LaTeX Workshop 配置信息"/><published>2022-02-25T12:33:00+00:00</published><updated>2022-02-25T12:33:00+00:00</updated><id>https://jkfx.github.io/blog/2022/LaTeX%20Workshop%20%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF</id><content type="html" xml:base="https://jkfx.github.io/blog/2022/LaTeX-Workshop-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"><![CDATA[<p>使用 VS Code 编写 LaTeX 论文时，安装 LaTeX Workshop 插件可以实现非常多的功能，但是由于 LaTeX Workshop 默认配置的编译命令是 <code class="language-plaintext highlighter-rouge">latexmk</code> ，而在编写中文论文时通常需要使用 <code class="language-plaintext highlighter-rouge">xelatex</code> 命令来编译文件源代码，所以为了正常使用 LaTeX Workshop 编写中文论文，通常需要对 LaTeX Workshop 进行自定义修改。</p> <p>以下是笔者根据官方文档自己修改的设置选项信息，每一项的设置上面都写好了中文注释，也为了日后笔者更方便的进行配置、修改。</p> <blockquote> <p>关于 LaTeX Workshop 的配置官方文档信息，可以参考 <a href="https://github.com/James-Yu/LaTeX-Workshop/wiki">LaTeX Workshop GitHub Wiki</a></p> </blockquote> <p>本文给出 3 种编译方式：</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">xelatex</code> 命令编译两次</li> </ul> <blockquote> <p>通常生成目录时，通常先编译一次生成目录所需的辅助文件，例如目录项等，然后编译第二遍结合辅助文件生成最终的 PDF</p> </blockquote> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">BibTeX</code> 参考文献工具时所需用到的编译命令</li> <li>使用 <code class="language-plaintext highlighter-rouge">BibLaTeX</code> 参考文献所需用到的编译命令</li> </ul> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ******** LaTeX Workshop 配置信息 ********</span>
<span class="c1">// 文件修改时不自动编译</span>
<span class="c1">// "never", "onSave", "onFileChange"</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.autoBuild.run</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">never</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// LaTeX Workshop 编译源代码文件的快捷键默认为：ctrl + alt + b</span>
<span class="c1">// 但是在有些情况下，ctrl + alt 快捷键被占用</span>
<span class="c1">// 将下面设置项改为 true 可以启动替代的快捷键</span>
<span class="c1">// ctrl + l / alt + letter</span>
<span class="dl">"</span><span class="s2">latex-workshop.bind.altKeymap.enabled</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="c1">// 编译文件时选用哪种 recipes 方案</span>
<span class="c1">// recipes 的定义在下文</span>
<span class="c1">// "first" （默认）为定义在下文 recipes 中的第一项</span>
<span class="c1">// "lastUsed" 为上次使用运行的 recipe</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.recipe.default</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">lastUsed</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// 预览生产的 pdf 文件方式：在 vscode 窗口中预览</span>
<span class="dl">"</span><span class="s2">latex-workshop.view.pdf.viewer</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">tab</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// 设置在使用 LaTeX Workshop 编译后，自动清理辅助文件</span>
<span class="c1">// 也可以设置为 "never" 表示不自动清理辅助文件</span>
<span class="c1">// 设置 "onFailed" 为当编译失败时自动清理辅助文件</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.autoClean.run</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">onBuilt</span><span class="dl">"</span><span class="p">,</span>
<span class="c1">// 编译 LaTeX 时使用的工具（tool）顺序</span>
<span class="c1">// 工具（tool）需要自定义</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.recipes</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
    <span class="c1">// 没有参考文献的编译方式</span>
    <span class="c1">// 为了正确生成目录项，一般需要编译两次源代码</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="c1">// 使用 BibTeX 参考文献工具的编译方式</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex ➞ bibtex ➞ xelatex × 2</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">bibtex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="c1">// 使用 BibLaTeX 参考文献工具的编译方式</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex ➞ biber ➞ xelatex × 2</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">biber</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">],</span>
<span class="c1">// 定义 recipes 中工具的命令以及参数</span>
<span class="c1">// 以下列出 LaTeX Workshop 定义好的占位符</span>
<span class="c1">// %DOC%             The root file full path without the extension</span>
<span class="c1">// %DOC_W32%         The root file full path without the extension with \ path separator on Windows</span>
<span class="c1">// %DOCFILE%         The root file name without the extension</span>
<span class="c1">// %DOC_EXT%         The root file full path with the extension</span>
<span class="c1">// %DOC_EXT_W32%     The root file full path with the extension with \ path separator on Windows</span>
<span class="c1">// %DOCFILE_EXT%     The root file name with the extension</span>
<span class="c1">// %DIR%             The root file directory</span>
<span class="c1">// %DIR_W32%         The root file directory with \ path separator on Windows</span>
<span class="c1">// %TMPDIR%             A temporary folder for storing ancillary files</span>
<span class="c1">// %OUTDIR%             The output directory configured in latex-workshop.latex.outDir</span>
<span class="c1">// %OUTDIR_W32%         The output directory configured in latex-workshop.latex.outDir with \ path separator on Windows</span>
<span class="c1">// %WORKSPACE_FOLDER% The current workspace path</span>
<span class="c1">// %RELATIVE_DIR%     The root file directory relative to the workspace folder</span>
<span class="c1">// %RELATIVE_DOC%     file root file path relative to the workspace folder</span>
<span class="dl">"</span><span class="s2">latex-workshop.latex.tools</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">command</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xelatex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">args</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">-synctex=1</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">-interaction=nonstopmode</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">-file-line-error</span><span class="dl">"</span><span class="p">,</span>
            <span class="dl">"</span><span class="s2">%DOC%</span><span class="dl">"</span>
        <span class="p">],</span>
        <span class="dl">"</span><span class="s2">env</span><span class="dl">"</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bibtex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">command</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bibtex</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">args</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">%DOCFILE%</span><span class="dl">"</span>
        <span class="p">],</span>
        <span class="dl">"</span><span class="s2">env</span><span class="dl">"</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">biber</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">command</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">biber</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">args</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
            <span class="dl">"</span><span class="s2">%DOCFILE%</span><span class="dl">"</span>
        <span class="p">],</span>
        <span class="dl">"</span><span class="s2">env</span><span class="dl">"</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">],</span>
</code></pre></div></div> <p>使用以上配置选项将上述代码拷贝到你的 VS Code 的 <code class="language-plaintext highlighter-rouge">json</code> 设置文件下即可。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[使用 VS Code 编写 LaTeX 论文时，安装 LaTeX Workshop 插件可以实现非常多的功能，但是由于 LaTeX Workshop 默认配置的编译命令是 latexmk ，而在编写中文论文时通常需要使用 xelatex 命令来编译文件源代码，所以为了正常使用 LaTeX Workshop 编写中文论文，通常需要对 LaTeX Workshop 进行自定义修改。]]></summary></entry><entry><title type="html">关于Linux下LaTeX无法找到已安装字体的问题与解决</title><link href="https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8ELinux%E4%B8%8BLaTeX%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%B7%B2%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/" rel="alternate" type="text/html" title="关于Linux下LaTeX无法找到已安装字体的问题与解决"/><published>2021-08-12T22:47:00+00:00</published><updated>2021-08-12T22:47:00+00:00</updated><id>https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8ELinux%E4%B8%8BLaTeX%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%B7%B2%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3</id><content type="html" xml:base="https://jkfx.github.io/blog/2021/%E5%85%B3%E4%BA%8ELinux%E4%B8%8BLaTeX%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%B7%B2%E5%AE%89%E8%A3%85%E5%AD%97%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"><![CDATA[<p>当我在Ubuntu系统下使用Latex时，在编译渲染时报出了<code class="language-plaintext highlighter-rouge">Font "xxx" does not contain requested</code>这种错误，其中<code class="language-plaintext highlighter-rouge">xxx</code>就是你可能想使用的字体格式。</p> <p>然而我的Ubuntu系统已经正确安装了一些常用中文字体，然而在LaTeX编译渲染时还会报出错误。</p> <p>由于笔者为了解决这个问题翻遍了国内外的网站、去查看了Texlive官方文档，耗费了许多时间与精力，都没能找到解决我的问题的信息，人们的时间往往都很珍贵，一般找不到解决方案过后，往往都不了了之，本着互联网极客精神（<strong>开源精神</strong>），在这里将笔者的解决过程记录并分享，希望人们可以将这种精神继承并传承下去。</p> <blockquote> <p>我甚至在Texlive的官方安装文档中看到这么一段话：</p> <p><img src="https://tva2.sinaimg.cn/large/006VTcCxly1gtee10q7x6j31f10cbqgx.jpg" alt="image"/></p> <p>可以看到关乎于LaTeX排版中让人非常头疼的问题就是汉字的一些处理了，好在今天有非常多好用的宏包可以解决处理这个问题。</p> </blockquote> <p>首先看一下笔者出现的问题：</p> <p><img src="https://tva3.sinaimg.cn/large/006VTcCxly1gtedg611ydj60w00a9q7w02.jpg" alt="image"/></p> <p><img src="https://tva4.sinaimg.cn/large/006VTcCxly1gtediiunx3j618z07d79402.jpg" alt="image"/></p> <p>可以看到终端给出的错误提示是未能找到已安装的字体（<em>installed font not found</em>），有了这句话的提示，笔者想的可能是，在我的系统上已安装了的字体中，在LaTeX中未能正确地引用，查看代码中可以看到：</p> <p><img src="https://tvax4.sinaimg.cn/large/006VTcCxly1gtedm8youxj30mt061jvl.jpg" alt="image"/></p> <p>在这里设置字体格式的时候我们设置楷体对应的字体文件为<code class="language-plaintext highlighter-rouge">simkai</code>，我们可以查看我们的字体库中是否有<code class="language-plaintext highlighter-rouge">simkai.ttf</code>楷体的字体文件：</p> <p>在Ubuntu存放字体的目录<code class="language-plaintext highlighter-rouge">/usr/share/fonts/</code>下可以使用<code class="language-plaintext highlighter-rouge">find</code>命令查找：</p> <p><img src="https://tva1.sinaimg.cn/large/006VTcCxly1gtedq0ili0j61570aigqc02.jpg" alt="image"/></p> <p>可以看到，笔者的系统中已经存放了<code class="language-plaintext highlighter-rouge">simkai.ttf</code>这个字体文件，为什么LaTeX还没有找到这个字体呢。</p> <p>通过一番排查，原来是在Ubuntu中，对字体的使用并不仅仅是字体文件名，而是另一个别名。</p> <p>我们可以使用<code class="language-plaintext highlighter-rouge">fc-list</code>来查看系统可用的字体列表，然后使用<code class="language-plaintext highlighter-rouge">grep</code>匹配<code class="language-plaintext highlighter-rouge">simkai.ttf</code>的字体文件，可以进一步查看字体的信息：</p> <p><img src="https://tva1.sinaimg.cn/large/006VTcCxly1gtedsq4tgrj61580r9b2902.jpg" alt="image"/></p> <p>原来，图中1号框中的名字只是字体文件名，而在系统应用中想要使用这个字体，我们需要指定2号框中的字体名，例如本图，我们想要使用楷体就需要指定<code class="language-plaintext highlighter-rouge">KaiTi</code>或<code class="language-plaintext highlighter-rouge">楷体</code>这个名字。</p> <p>回到LaTeX代码中，将之前出现错误原因的<code class="language-plaintext highlighter-rouge">simkai</code>替换成<code class="language-plaintext highlighter-rouge">KaiTi</code>即可解决问题。</p> <p><img src="https://tva4.sinaimg.cn/large/006VTcCxly1gtedwcpyd0j60no06dtd402.jpg" alt="image"/></p> <p><img src="https://tvax3.sinaimg.cn/large/006VTcCxly1gteduycwvij60i102swf302.jpg" alt="image"/></p> <p>为了进一步验证笔者的猜想，可以看到上图代码中，在<code class="language-plaintext highlighter-rouge">KaiTi</code>的下面还使用了<code class="language-plaintext highlighter-rouge">SimSun</code>宋体的使用，然而<code class="language-plaintext highlighter-rouge">SimSun</code>并不报错，这里笔者想可以继续查看<code class="language-plaintext highlighter-rouge">SimSun</code>的字体信息，其后面的别名应该包含<code class="language-plaintext highlighter-rouge">SimSun</code>。</p> <p><img src="https://tva2.sinaimg.cn/large/006VTcCxly1gtedz60mqcj61540r77wh02.jpg" alt="image"/></p> <p>所以笔者的猜想是正确的，所以在我们不同的系统、不同的字体文件中，每个人发生无法正确找到我们想要使用的字体的错误可能都不一样，因为我们使用的字体文件不同可能导致我们的在应用中使用字体中需要引用的名称的不同而不同，所以出现这种问题我们要具体问题具体分析，对症下药。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[当我在Ubuntu系统下使用Latex时，在编译渲染时报出了Font "xxx" does not contain requested这种错误，其中xxx就是你可能想使用的字体格式。]]></summary></entry><entry><title type="html">Ubuntu 21.04 使用命令行分配静态IP地址</title><link href="https://jkfx.github.io/blog/2021/Ubuntu-21.04-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E9%85%8D%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/" rel="alternate" type="text/html" title="Ubuntu 21.04 使用命令行分配静态IP地址"/><published>2021-08-03T15:43:00+00:00</published><updated>2021-08-03T15:43:00+00:00</updated><id>https://jkfx.github.io/blog/2021/Ubuntu%2021.04%20%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E9%85%8D%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80</id><content type="html" xml:base="https://jkfx.github.io/blog/2021/Ubuntu-21.04-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E9%85%8D%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/"><![CDATA[<h2 id="查看网卡-logical-name">查看网卡 logical name</h2> <p>输入 <code class="language-plaintext highlighter-rouge">sudo lshw -class network</code> 后回车，在列出的信息中找到 <code class="language-plaintext highlighter-rouge">local name</code> 键，查看其后面的值是多少。</p> <p><img src="//tva3.sinaimg.cn/large/006VTcCxly1gt3mt42tx4j315w0tsb1j.jpg" alt="image"/></p> <h2 id="编辑配置文件">编辑配置文件</h2> <p>以本文的 <code class="language-plaintext highlighter-rouge">ens32</code> 为例，下面我们进入到 <code class="language-plaintext highlighter-rouge">/etc/netplan</code> 目录下，使用 <code class="language-plaintext highlighter-rouge">cd /etc/netplan</code> 命令。</p> <p>然后使用 <code class="language-plaintext highlighter-rouge">sudo vim 99_config.yaml</code> 创建一个名为 <code class="language-plaintext highlighter-rouge">99_config.yaml</code> 的配置文件，并且在配置文件中编辑输入我们需要的网络地址信息。</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">network</span><span class="pi">:</span>
  <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">renderer</span><span class="pi">:</span> <span class="s">networkd</span>
  <span class="na">ethernets</span><span class="pi">:</span>
    <span class="na">ens32</span><span class="pi">:</span>
      <span class="na">addresses</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">192.168.187.101/24</span>
      <span class="na">gateway4</span><span class="pi">:</span> <span class="s">192.168.187.2</span>
      <span class="na">nameservers</span><span class="pi">:</span>
          <span class="na">search</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">mydomain</span><span class="pi">,</span> <span class="nv">otherdomain</span><span class="pi">]</span>
          <span class="na">addresses</span><span class="pi">:</span> <span class="pi">[</span><span class="nv">114.114.114.114</span><span class="pi">,</span> <span class="nv">8.8.8.8</span><span class="pi">]</span>
</code></pre></div></div> <p><img src="//tvax3.sinaimg.cn/large/006VTcCxly1gt3n4s2pmaj317d0tuk3t.jpg" alt="image"/></p> <p>如图所示，讲配置文件中的键值对配置成我们需要的网络信息后，输入 <code class="language-plaintext highlighter-rouge">:wq</code> 保存并且退出。</p> <h2 id="刷新生效配置文件">刷新生效配置文件</h2> <p>然后我们输入 <code class="language-plaintext highlighter-rouge">sudo netplan apply</code> 将配置文件生效即可。</p> <p>可以输入 <code class="language-plaintext highlighter-rouge">ip a</code> 查看网络信息是否生效。</p> <p><img src="//tvax3.sinaimg.cn/large/006VTcCxly1gt3n6scooij31990t01kx.jpg" alt="image"/></p> <p>可以看到图中的IP地址已经变成了我们所需要的地址。</p> <h2 id="参考文档">参考文档</h2> <p><a href="https://ubuntu.com/server/docs/network-configuration">Network Configuration</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[查看网卡 logical name]]></summary></entry><entry><title type="html">批量下载YouTube播放列表（playlist）视频、字幕</title><link href="https://jkfx.github.io/blog/2021/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDYouTube%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8-playlist-%E8%A7%86%E9%A2%91-%E5%AD%97%E5%B9%95/" rel="alternate" type="text/html" title="批量下载YouTube播放列表（playlist）视频、字幕"/><published>2021-07-21T15:30:00+00:00</published><updated>2021-07-21T15:30:00+00:00</updated><id>https://jkfx.github.io/blog/2021/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDYouTube%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8%EF%BC%88playlist%EF%BC%89%E8%A7%86%E9%A2%91%E3%80%81%E5%AD%97%E5%B9%95</id><content type="html" xml:base="https://jkfx.github.io/blog/2021/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDYouTube%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8-playlist-%E8%A7%86%E9%A2%91-%E5%AD%97%E5%B9%95/"><![CDATA[<h2 id="所需工具">所需工具</h2> <ul> <li><a href="https://www.python.org/downloads/">python</a></li> <li><a href="https://github.com/ytdl-org/youtube-dl/releases">youtube-dl</a></li> <li><a href="http://ffmpeg.org/download.html">FFmpeg</a></li> <li><em>Scientific上网</em></li> </ul> <p>其实可以直接使用<em>youtube-dl</em>执行文件直接下载，若我们需要对多个<em>YouTube</em>播放列表进行批量下载，便可利用<em>python</em>进行批处理，其中本文实现的功能就是对多个<em>YouTube</em>播放列表都创建一个对应的同名文件夹，然后将视频、字幕文件全部下载到一起。</p> <p>其中<em>FFmpeg</em>是<em>youtube-dl</em>用来合并视音频文件用的，虽然<em>YouTube</em>上视频的格式有<em>MP4</em>的格式，不需要对视频、音频文件进行合并，如果你需要下载<em>2K</em>、<em>4K</em>的高清晰度的视频文件，一般都是采用<em><a href="https://baike.baidu.com/item/WebM/2455966?fr=aladdin">webm</a></em>的格式将视频、音频文件分开。尽管如此，<em>youtube-dl</em>也已经为我们造好了轮子，合并视音频文件的步骤无需我们干扰，只需要将其所用的工具添加到系统的<strong>环境变量</strong>。</p> <p><strong>再次说明</strong>，你需要将下载下来的<em>youtube-dl</em>的可执行文件，以及<em>FFmpeg</em>的<strong><em>bin</em></strong>目录都添加到系统的<strong>环境变量</strong>中。</p> <h2 id="实现代码">实现代码</h2> <p>首先创建python的字典，其中<em>key</em>是播放列表的名称，也是将要创建文件夹的名称，<em>value</em>是播放列表（playlist）对应的YouTube链接。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">key(播放列表的名称，也即创建文件夹的名称)</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">YouTube播放列表链接</span><span class="sh">"</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里以麻省理工公开课<a href="http://introtodeeplearning.com/">MIT 6.S191</a>为例，打开对应课程的YouTube播放列表。</p> <p><img src="//tva1.sinaimg.cn/large/006VTcCxgy1gsokx7w77oj31z2164e81.jpg" alt="image"/></p> <p>将对应播放列表的名称和链接放入python字典中。</p> <p>然后直接遍历此字典的<em>key</em>和<em>value</em>使用<em>os</em>库的<em>system</em>方法调用<em>youtube-dl</em>命令对视音频进行下载。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">for </span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">m</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="c1"># 创建同名文件夹
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># 进入到刚刚创建的文件夹中
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># 调用 youtube-dl 命令对视频链接进行下载
</span>    <span class="c1"># 本条命令下载的字幕是英文
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-sub --sub-lang en -f </span><span class="sh">"</span><span class="s">bestvideo+bestaudio</span><span class="sh">"</span><span class="s"> -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># 如果需要下载自动翻译的中文字幕，便需要执行下一行
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-auto-sub --sub-lang zh-Hans --skip-download -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># 返回到上一级目录
</span>    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="sh">"</span><span class="s">../</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <blockquote> <p>即使<em><a href="https://github.com/ytdl-org/youtube-dl/blob/master/README.md">youtube-dl</a></em>的<em>GitHub</em>上已经有非常详细的命令参数的说明，这里还是简单地说明一下。</p> <p>语法格式大体为：youtube-dl [OPTIONS] URL [URL…]</p> <p>本文所用到的选项有：</p> <ul> <li><em>–write-sub</em> 下载视频对应的字幕文件</li> <li><em>–sub-lang</em> 指定下载字幕文件的语言 <ul> <li><em>en</em> 英语</li> <li><em>zh-Hans</em> 中文简体</li> </ul> </li> <li><em>–write-auto-sub</em> 当原视频文件没有带中文简体的字幕时，需要使用本参数下载<em>自动翻译</em>的字幕文件</li> <li><em>-f</em> 指定视频格式 <ul> <li>这里的<em>bestvideo+bestaudio</em>的意思是下载视频清晰度最好的视频文件和音频质量最好的音频文件并且将它们合并</li> </ul> </li> <li><em>-o</em> 指定下载的文件的名称 <ul> <li><em>%(title)s</em> 表明视频文件的标题名</li> <li><em>%(ext)s</em> 下载文件的扩展格式</li> <li><em>%(autonumber)s</em> 如果你想要对每个下载文件名称前面加上一个序号，便使用这个参数</li> </ul> </li> <li><em>–skip-download</em> 跳过视频文件仅下载字幕文件</li> </ul> </blockquote> <h2 id="完整代码">完整代码</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">MIT 6.046J Design and Analysis of Algorithms, Spring 2015</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 6.042J Mathematics for Computer Science, Fall 2010</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PLB7540DEDD482705B</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 18.065 Matrix Methods in Data Analysis, Signal Processing, and Machine Learning, Spring 2018</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PLUl4u3cNGP63oMNUHXqIUcrkS2PivhN3k</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 18.02 Multivariable Calculus, Fall 2007</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PL4C4C8A7D06566F38</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">MIT 18.01 Single Variable Calculus, Fall 2006</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">https://www.youtube.com/playlist?list=PL590CCC2BC5AF3BC1</span><span class="sh">"</span>
<span class="p">}</span>

<span class="nf">for </span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">m</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-sub --sub-lang en -f </span><span class="sh">"</span><span class="s">bestvideo+bestaudio</span><span class="sh">"</span><span class="s"> -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">'</span><span class="s">youtube-dl --write-auto-sub --sub-lang zh-Hans --skip-download -o </span><span class="sh">"</span><span class="s">%(title)s.%(ext)s</span><span class="sh">"</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="sh">"</span><span class="s">../</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>将代码中字典变量的<em>key</em>和<em>value</em>替换成你需要的下载链接，将其保存到<code class="language-plaintext highlighter-rouge">.py</code>文件格式后，执行<code class="language-plaintext highlighter-rouge">python 文件名.py</code>便可进行下载。</p> <h2 id="效果展示">效果展示</h2> <p>如果你的梯子网速给力的话，下载速度还是非常可观的。</p> <p><img src="//tvax2.sinaimg.cn/large/006VTcCxgy1gsolqbnjbzj31ta0zhgwg.jpg" alt="image"/></p> <p><img src="//tva3.sinaimg.cn/large/006VTcCxgy1gsolomow99j31z4168kjl.jpg" alt="image"/></p>]]></content><author><name></name></author><summary type="html"><![CDATA[所需工具]]></summary></entry></feed>